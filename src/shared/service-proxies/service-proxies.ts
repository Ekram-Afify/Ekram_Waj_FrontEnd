/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }
}

@Injectable()
export class AdminCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AdminCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminCategory/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AdminCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AdminCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminCategoryDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdminCategoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminCategory/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AdminCategoryDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminCategoryDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdminCategoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminCategoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminCategoryDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AdminCreateCategoryDto | undefined): Observable<AdminCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminCategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AdminCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AdminCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminCategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AdminUpdateCategoryDto | undefined): Observable<AdminCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AdminCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdminCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminCategoryDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdminCategory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AdminClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProfile(body: AdminCreateClientDto | undefined): Observable<AdminClientDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminClient/CreateProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProfile(<any>response_);
                } catch (e) {
                    return <Observable<AdminClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProfile(response: HttpResponseBase): Observable<AdminClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminClientDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfile(body: AdminUpdateClientDto | undefined): Observable<AdminClientDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminClient/UpdateProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfile(<any>response_);
                } catch (e) {
                    return <Observable<AdminClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfile(response: HttpResponseBase): Observable<AdminClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminClientDto>(<any>null);
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    getAllClients(email: string | undefined): Observable<AdminClientDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AdminClient/GetAllClients?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllClients(<any>response_);
                } catch (e) {
                    return <Observable<AdminClientDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminClientDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllClients(response: HttpResponseBase): Observable<AdminClientDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AdminClientDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminClientDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AdminClientDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminClient/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AdminClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AdminClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminClientDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isNewClients (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isNewClients: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdminClientDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminClient/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isNewClients === null)
            throw new Error("The parameter 'isNewClients' cannot be null.");
        else if (isNewClients !== undefined)
            url_ += "IsNewClients=" + encodeURIComponent("" + isNewClients) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AdminClientDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminClientDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdminClientDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminClientDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminClientDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AdminCreateClientDto | undefined): Observable<AdminClientDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminClient/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AdminClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AdminClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminClientDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AdminUpdateClientDto | undefined): Observable<AdminClientDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminClient/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AdminClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdminClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminClientDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdminClient/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AdminClientAdressServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AdminClientAdressDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminClientAdress/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AdminClientAdressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminClientAdressDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AdminClientAdressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminClientAdressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminClientAdressDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param clientId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, clientId: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdminClientAdressDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminClientAdress/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AdminClientAdressDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminClientAdressDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdminClientAdressDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminClientAdressDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminClientAdressDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AdminCreateClientAdressDto | undefined): Observable<AdminClientAdressDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminClientAdress/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AdminClientAdressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminClientAdressDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AdminClientAdressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminClientAdressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminClientAdressDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AdminUpdateClientAdressDto | undefined): Observable<AdminClientAdressDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminClientAdress/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AdminClientAdressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminClientAdressDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdminClientAdressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminClientAdressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminClientAdressDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdminClientAdress/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AdminCompanyClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AdminUpdateCompanyClientDto | undefined): Observable<AdminCompanyClientDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminCompanyClient/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AdminCompanyClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminCompanyClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdminCompanyClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminCompanyClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminCompanyClientDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AdminCompanyClientDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminCompanyClient/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AdminCompanyClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminCompanyClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AdminCompanyClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminCompanyClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminCompanyClientDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param companyId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, companyId: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdminCompanyClientDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminCompanyClient/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AdminCompanyClientDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminCompanyClientDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdminCompanyClientDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminCompanyClientDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminCompanyClientDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AdminCreateCompanyClientDto | undefined): Observable<AdminCompanyClientDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminCompanyClient/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AdminCompanyClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminCompanyClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AdminCompanyClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminCompanyClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminCompanyClientDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdminCompanyClient/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AdminDriverServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerDriver(body: AdminCreateWaselDriverDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AdminDriver/RegisterDriver";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterDriver(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterDriver(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterDriver(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProfile(body: AdminCreateDriverDto | undefined): Observable<MessageModel> {
        let url_ = this.baseUrl + "/api/services/app/AdminDriver/CreateProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProfile(<any>response_);
                } catch (e) {
                    return <Observable<MessageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProfile(response: HttpResponseBase): Observable<MessageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfile(body: AdminUpdateDriverDto | undefined): Observable<MessageModel> {
        let url_ = this.baseUrl + "/api/services/app/AdminDriver/UpdateProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfile(<any>response_);
                } catch (e) {
                    return <Observable<MessageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfile(response: HttpResponseBase): Observable<MessageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageModel>(<any>null);
    }

    /**
     * @param email (optional) 
     * @param fullName (optional) 
     * @return Success
     */
    getAllDrivers(email: string | undefined, fullName: string | undefined): Observable<DriverDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AdminDriver/GetAllDrivers?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (fullName === null)
            throw new Error("The parameter 'fullName' cannot be null.");
        else if (fullName !== undefined)
            url_ += "FullName=" + encodeURIComponent("" + fullName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDrivers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDrivers(<any>response_);
                } catch (e) {
                    return <Observable<DriverDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DriverDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDrivers(response: HttpResponseBase): Observable<DriverDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DriverDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverDto[]>(<any>null);
    }

    /**
     * @param driverId (optional) 
     * @return Success
     */
    manageWaselDriver(driverId: number | undefined): Observable<WaselResponseDTOC> {
        let url_ = this.baseUrl + "/api/services/app/AdminDriver/ManageWaselDriver?";
        if (driverId === null)
            throw new Error("The parameter 'driverId' cannot be null.");
        else if (driverId !== undefined)
            url_ += "driverId=" + encodeURIComponent("" + driverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManageWaselDriver(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManageWaselDriver(<any>response_);
                } catch (e) {
                    return <Observable<WaselResponseDTOC>><any>_observableThrow(e);
                }
            } else
                return <Observable<WaselResponseDTOC>><any>_observableThrow(response_);
        }));
    }

    protected processManageWaselDriver(response: HttpResponseBase): Observable<WaselResponseDTOC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WaselResponseDTOC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WaselResponseDTOC>(<any>null);
    }

    /**
     * @param driverId (optional) 
     * @return Success
     */
    manageWaselVehicle(driverId: number | undefined): Observable<WaselResponseDTOC> {
        let url_ = this.baseUrl + "/api/services/app/AdminDriver/ManageWaselVehicle?";
        if (driverId === null)
            throw new Error("The parameter 'driverId' cannot be null.");
        else if (driverId !== undefined)
            url_ += "driverId=" + encodeURIComponent("" + driverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManageWaselVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManageWaselVehicle(<any>response_);
                } catch (e) {
                    return <Observable<WaselResponseDTOC>><any>_observableThrow(e);
                }
            } else
                return <Observable<WaselResponseDTOC>><any>_observableThrow(response_);
        }));
    }

    protected processManageWaselVehicle(response: HttpResponseBase): Observable<WaselResponseDTOC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WaselResponseDTOC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WaselResponseDTOC>(<any>null);
    }

    /**
     * @return Success
     */
    getUnPricedDrivers(): Observable<SelectedDriver[]> {
        let url_ = this.baseUrl + "/api/services/app/AdminDriver/GetUnPricedDrivers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnPricedDrivers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnPricedDrivers(<any>response_);
                } catch (e) {
                    return <Observable<SelectedDriver[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectedDriver[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnPricedDrivers(response: HttpResponseBase): Observable<SelectedDriver[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectedDriver.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectedDriver[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AdminDriverDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminDriver/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AdminDriverDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminDriverDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AdminDriverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminDriverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminDriverDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param companyId (optional) 
     * @param subcategoryId (optional) 
     * @param isAvilible (optional) 
     * @param isWaselDriver (optional) 
     * @param isWaselVehicle (optional) 
     * @param isMakeOfferPrice (optional) 
     * @param isReceiveOrder (optional) 
     * @param isNewDrivers (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, companyId: number | undefined, subcategoryId: number | undefined, isAvilible: boolean | undefined, isWaselDriver: boolean | undefined, isWaselVehicle: boolean | undefined, isMakeOfferPrice: boolean | undefined, isReceiveOrder: boolean | undefined, isNewDrivers: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdminDriverDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminDriver/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (subcategoryId === null)
            throw new Error("The parameter 'subcategoryId' cannot be null.");
        else if (subcategoryId !== undefined)
            url_ += "SubcategoryId=" + encodeURIComponent("" + subcategoryId) + "&";
        if (isAvilible === null)
            throw new Error("The parameter 'isAvilible' cannot be null.");
        else if (isAvilible !== undefined)
            url_ += "IsAvilible=" + encodeURIComponent("" + isAvilible) + "&";
        if (isWaselDriver === null)
            throw new Error("The parameter 'isWaselDriver' cannot be null.");
        else if (isWaselDriver !== undefined)
            url_ += "IsWaselDriver=" + encodeURIComponent("" + isWaselDriver) + "&";
        if (isWaselVehicle === null)
            throw new Error("The parameter 'isWaselVehicle' cannot be null.");
        else if (isWaselVehicle !== undefined)
            url_ += "IsWaselVehicle=" + encodeURIComponent("" + isWaselVehicle) + "&";
        if (isMakeOfferPrice === null)
            throw new Error("The parameter 'isMakeOfferPrice' cannot be null.");
        else if (isMakeOfferPrice !== undefined)
            url_ += "IsMakeOfferPrice=" + encodeURIComponent("" + isMakeOfferPrice) + "&";
        if (isReceiveOrder === null)
            throw new Error("The parameter 'isReceiveOrder' cannot be null.");
        else if (isReceiveOrder !== undefined)
            url_ += "IsReceiveOrder=" + encodeURIComponent("" + isReceiveOrder) + "&";
        if (isNewDrivers === null)
            throw new Error("The parameter 'isNewDrivers' cannot be null.");
        else if (isNewDrivers !== undefined)
            url_ += "IsNewDrivers=" + encodeURIComponent("" + isNewDrivers) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AdminDriverDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminDriverDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdminDriverDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminDriverDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminDriverDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AdminCreateDriverDto | undefined): Observable<AdminDriverDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminDriver/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AdminDriverDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminDriverDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AdminDriverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminDriverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminDriverDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AdminUpdateDriverDto | undefined): Observable<AdminDriverDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminDriver/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AdminDriverDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminDriverDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdminDriverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminDriverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminDriverDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdminDriver/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AdminOfferPriceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param driverName (optional) 
     * @param email (optional) 
     * @param phone (optional) 
     * @return Success
     */
    getTopRequestSalesDrivers(driverName: string | undefined, email: string | undefined, phone: string | undefined): Observable<TopRequestSalesDriverDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AdminOfferPrice/GetTopRequestSalesDrivers?";
        if (driverName === null)
            throw new Error("The parameter 'driverName' cannot be null.");
        else if (driverName !== undefined)
            url_ += "DriverName=" + encodeURIComponent("" + driverName) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopRequestSalesDrivers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopRequestSalesDrivers(<any>response_);
                } catch (e) {
                    return <Observable<TopRequestSalesDriverDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TopRequestSalesDriverDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopRequestSalesDrivers(response: HttpResponseBase): Observable<TopRequestSalesDriverDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TopRequestSalesDriverDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TopRequestSalesDriverDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AdminOfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminOfferPrice/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AdminOfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminOfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AdminOfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminOfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminOfferPriceDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param requestId (optional) 
     * @param clientName (optional) 
     * @param driverName (optional) 
     * @param rate (optional) 
     * @param isClient (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, requestId: number | undefined, clientName: string | undefined, driverName: string | undefined, rate: number | undefined, isClient: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdminOfferPriceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminOfferPrice/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "RequestId=" + encodeURIComponent("" + requestId) + "&";
        if (clientName === null)
            throw new Error("The parameter 'clientName' cannot be null.");
        else if (clientName !== undefined)
            url_ += "ClientName=" + encodeURIComponent("" + clientName) + "&";
        if (driverName === null)
            throw new Error("The parameter 'driverName' cannot be null.");
        else if (driverName !== undefined)
            url_ += "DriverName=" + encodeURIComponent("" + driverName) + "&";
        if (rate === null)
            throw new Error("The parameter 'rate' cannot be null.");
        else if (rate !== undefined)
            url_ += "Rate=" + encodeURIComponent("" + rate) + "&";
        if (isClient === null)
            throw new Error("The parameter 'isClient' cannot be null.");
        else if (isClient !== undefined)
            url_ += "IsClient=" + encodeURIComponent("" + isClient) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AdminOfferPriceDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminOfferPriceDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdminOfferPriceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminOfferPriceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminOfferPriceDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AdminCreateOfferPriceDto | undefined): Observable<AdminOfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminOfferPrice/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AdminOfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminOfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AdminOfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminOfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminOfferPriceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AdminUpdateOfferPriceDto | undefined): Observable<AdminOfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminOfferPrice/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AdminOfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminOfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdminOfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminOfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminOfferPriceDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdminOfferPrice/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AdminPanelUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPanelUser(body: AdminCreatePanelUserDto | undefined): Observable<AdminPanelUserDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminPanelUser/CreatePanelUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePanelUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePanelUser(<any>response_);
                } catch (e) {
                    return <Observable<AdminPanelUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminPanelUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePanelUser(response: HttpResponseBase): Observable<AdminPanelUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminPanelUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminPanelUserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePanelUser(body: AdminUpdatePanelUserDto | undefined): Observable<AdminPanelUserDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminPanelUser/UpdatePanelUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePanelUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePanelUser(<any>response_);
                } catch (e) {
                    return <Observable<AdminPanelUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminPanelUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePanelUser(response: HttpResponseBase): Observable<AdminPanelUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminPanelUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminPanelUserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<AdminPanelUserDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminPanelUser/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<AdminPanelUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminPanelUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AdminPanelUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminPanelUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminPanelUserDto>(<any>null);
    }

    /**
     * @param roleName (optional) 
     * @param body (optional) 
     * @return Success
     */
    createPanelRole(roleName: string | undefined, body: string[] | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminPanelUser/CreatePanelRole?";
        if (roleName === null)
            throw new Error("The parameter 'roleName' cannot be null.");
        else if (roleName !== undefined)
            url_ += "RoleName=" + encodeURIComponent("" + roleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePanelRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePanelRole(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePanelRole(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param panelUserId (optional) 
     * @return Success
     */
    manageAvailable(panelUserId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/AdminPanelUser/ManageAvailable?";
        if (panelUserId === null)
            throw new Error("The parameter 'panelUserId' cannot be null.");
        else if (panelUserId !== undefined)
            url_ += "PanelUserId=" + encodeURIComponent("" + panelUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManageAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManageAvailable(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processManageAvailable(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AdminPanelUserDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminPanelUser/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AdminPanelUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminPanelUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AdminPanelUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminPanelUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminPanelUserDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param roleId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, roleId: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdminPanelUserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminPanelUser/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AdminPanelUserDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminPanelUserDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdminPanelUserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminPanelUserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminPanelUserDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AdminCreatePanelUserDto | undefined): Observable<AdminPanelUserDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminPanelUser/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AdminPanelUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminPanelUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AdminPanelUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminPanelUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminPanelUserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AdminUpdatePanelUserDto | undefined): Observable<AdminPanelUserDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminPanelUser/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AdminPanelUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminPanelUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdminPanelUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminPanelUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminPanelUserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdminPanelUser/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AdminPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AdminPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminPayment/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AdminPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AdminPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminPaymentDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdminPaymentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminPayment/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AdminPaymentDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminPaymentDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdminPaymentDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminPaymentDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminPaymentDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AdminPaymentDto | undefined): Observable<AdminPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminPayment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AdminPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AdminPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminPaymentDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AdminPaymentDto | undefined): Observable<AdminPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminPayment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AdminPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdminPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminPaymentDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdminPayment/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AdminRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    regTrip(body: Trip | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AdminRequest/RegTrip";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegTrip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegTrip(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processRegTrip(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTrip(body: Trip | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/AdminRequest/UpdateTrip";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTrip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTrip(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTrip(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRequest(body: AdminCreateRequestDto | undefined): Observable<AdminRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminRequest/CreateRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRequest(<any>response_);
                } catch (e) {
                    return <Observable<AdminRequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminRequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRequest(response: HttpResponseBase): Observable<AdminRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminRequestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AdminRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminRequest/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AdminRequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminRequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AdminRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminRequestDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AdminUpdateRquestDto | undefined): Observable<AdminRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminRequest/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AdminRequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminRequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdminRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminRequestDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRequestFromAdminPanel(body: AdminCreateRequestWithOfferDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AdminRequest/CreateRequestFromAdminPanel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRequestFromAdminPanel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRequestFromAdminPanel(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRequestFromAdminPanel(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updaterequestFromAdminPanel(body: AdminCreateRequestWithOfferDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/AdminRequest/UpdaterequestFromAdminPanel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdaterequestFromAdminPanel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdaterequestFromAdminPanel(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdaterequestFromAdminPanel(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cancelRequestFromAdminPanel(input: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/AdminRequest/CancelRequestFromAdminPanel?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelRequestFromAdminPanel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelRequestFromAdminPanel(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCancelRequestFromAdminPanel(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param phone (optional) 
     * @param email (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @return Success
     */
    getTopRequestSalesClients(phone: string | undefined, email: string | undefined, firstName: string | undefined, lastName: string | undefined): Observable<TopRequestSalesClientDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AdminRequest/GetTopRequestSalesClients?";
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (firstName === null)
            throw new Error("The parameter 'firstName' cannot be null.");
        else if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName === null)
            throw new Error("The parameter 'lastName' cannot be null.");
        else if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopRequestSalesClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopRequestSalesClients(<any>response_);
                } catch (e) {
                    return <Observable<TopRequestSalesClientDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TopRequestSalesClientDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopRequestSalesClients(response: HttpResponseBase): Observable<TopRequestSalesClientDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TopRequestSalesClientDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TopRequestSalesClientDto[]>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param subcategoryId (optional) 
     * @param companyId (optional) 
     * @param keyWord (optional) 
     * @param isNewRequest (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(status: number | undefined, subcategoryId: number | undefined, companyId: number | undefined, keyWord: string | undefined, isNewRequest: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdminRequestDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminRequest/GetAll?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (subcategoryId === null)
            throw new Error("The parameter 'subcategoryId' cannot be null.");
        else if (subcategoryId !== undefined)
            url_ += "SubcategoryId=" + encodeURIComponent("" + subcategoryId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (keyWord === null)
            throw new Error("The parameter 'keyWord' cannot be null.");
        else if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (isNewRequest === null)
            throw new Error("The parameter 'isNewRequest' cannot be null.");
        else if (isNewRequest !== undefined)
            url_ += "IsNewRequest=" + encodeURIComponent("" + isNewRequest) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AdminRequestDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminRequestDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdminRequestDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminRequestDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminRequestDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AdminCreateRequestDto | undefined): Observable<AdminRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminRequest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AdminRequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminRequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AdminRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminRequestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdminRequest/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AdminSubategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param categoryId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, categoryId: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdminSubcategoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminSubategory/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AdminSubcategoryDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminSubcategoryDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdminSubcategoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminSubcategoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminSubcategoryDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AdminSubcategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminSubategory/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AdminSubcategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminSubcategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AdminSubcategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminSubcategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminSubcategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AdminCreateSubcategoryDto | undefined): Observable<AdminSubcategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminSubategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AdminSubcategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminSubcategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AdminSubcategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminSubcategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminSubcategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AdminUpdateSubcategoryDto | undefined): Observable<AdminSubcategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminSubategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AdminSubcategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminSubcategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdminSubcategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminSubcategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminSubcategoryDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdminSubategory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AdminVechileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createVechile(body: CreateAdminVechileDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AdminVechile/CreateVechile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVechile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVechile(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateVechile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AdminVechileDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminVechile/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AdminVechileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminVechileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AdminVechileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminVechileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminVechileDto>(<any>null);
    }

    /**
     * @param keyWord (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyWord: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdminVechileDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminVechile/GetAll?";
        if (keyWord === null)
            throw new Error("The parameter 'keyWord' cannot be null.");
        else if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AdminVechileDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminVechileDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdminVechileDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminVechileDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminVechileDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAdminVechileDto | undefined): Observable<AdminVechileDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminVechile/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AdminVechileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminVechileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AdminVechileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminVechileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminVechileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAdminVechileDto | undefined): Observable<AdminVechileDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminVechile/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AdminVechileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminVechileDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdminVechileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminVechileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminVechileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdminVechile/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AdminWaselDriverServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AdminWaselDriverDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminWaselDriver/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AdminWaselDriverDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminWaselDriverDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AdminWaselDriverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminWaselDriverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminWaselDriverDto>(<any>null);
    }

    /**
     * @param keyWord (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyWord: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AdminWaselDriverDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminWaselDriver/GetAll?";
        if (keyWord === null)
            throw new Error("The parameter 'keyWord' cannot be null.");
        else if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AdminWaselDriverDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminWaselDriverDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdminWaselDriverDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminWaselDriverDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminWaselDriverDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AdminCreateWaselDriverDto | undefined): Observable<AdminWaselDriverDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminWaselDriver/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AdminWaselDriverDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminWaselDriverDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AdminWaselDriverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminWaselDriverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminWaselDriverDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AdminUpdateWaselDriverDto | undefined): Observable<AdminWaselDriverDto> {
        let url_ = this.baseUrl + "/api/services/app/AdminWaselDriver/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AdminWaselDriverDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminWaselDriverDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdminWaselDriverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminWaselDriverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminWaselDriverDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdminWaselDriver/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param name (optional) 
     * @param categoryId (optional) 
     * @return Success
     */
    getAllCategories(name: string | undefined, categoryId: number | undefined): Observable<Category[]> {
        let url_ = this.baseUrl + "/api/services/app/Category/GetAllCategories?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCategories(<any>response_);
                } catch (e) {
                    return <Observable<Category[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Category[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCategories(response: HttpResponseBase): Observable<Category[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Category.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Category/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CategoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Category/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CategoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCategoryDto | undefined): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Category/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCategoryDto | undefined): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Category/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Category/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getProfile(): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfile(<any>response_);
                } catch (e) {
                    return <Observable<ClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfile(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProfile(body: CreateClientDto | undefined): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/CreateProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProfile(<any>response_);
                } catch (e) {
                    return <Observable<ClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProfile(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfile(body: UpdateClientDto | undefined): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/UpdateProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfile(<any>response_);
                } catch (e) {
                    return <Observable<ClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfile(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    isHasDriverProfile(userId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Client/IsHasDriverProfile?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsHasDriverProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsHasDriverProfile(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsHasDriverProfile(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    isHasClientCompanyProfile(userId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Client/IsHasClientCompanyProfile?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsHasClientCompanyProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsHasClientCompanyProfile(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsHasClientCompanyProfile(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ClientDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ClientDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ClientDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateClientDto | undefined): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateClientDto | undefined): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ClientAdressServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getClientDress(): Observable<ClientAdressDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ClientAdress/GetClientDress";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientDress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientDress(<any>response_);
                } catch (e) {
                    return <Observable<ClientAdressDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientAdressDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientDress(response: HttpResponseBase): Observable<ClientAdressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ClientAdressDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAdressDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateClientAddress(body: UpdateClientAdressDto | undefined): Observable<ClientAdressDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientAdress/UpdateClientAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClientAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClientAddress(<any>response_);
                } catch (e) {
                    return <Observable<ClientAdressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientAdressDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateClientAddress(response: HttpResponseBase): Observable<ClientAdressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientAdressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAdressDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ClientAdressDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientAdress/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ClientAdressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientAdressDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ClientAdressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientAdressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAdressDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ClientAdressDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientAdress/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ClientAdressDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientAdressDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ClientAdressDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientAdressDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAdressDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateClientAdressDto | undefined): Observable<ClientAdressDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientAdress/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ClientAdressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientAdressDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ClientAdressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientAdressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAdressDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateClientAdressDto | undefined): Observable<ClientAdressDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientAdress/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ClientAdressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientAdressDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ClientAdressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientAdressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAdressDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ClientAdress/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ClientAppConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTermsAndPolicy(): Observable<TermsAndPolicyDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientAppConfig/GetTermsAndPolicy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTermsAndPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTermsAndPolicy(<any>response_);
                } catch (e) {
                    return <Observable<TermsAndPolicyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TermsAndPolicyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTermsAndPolicy(response: HttpResponseBase): Observable<TermsAndPolicyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TermsAndPolicyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TermsAndPolicyDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setTermsAndPolicy(body: CreateTermsAndPolicyDto | undefined): Observable<TermsAndPolicyDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientAppConfig/SetTermsAndPolicy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTermsAndPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTermsAndPolicy(<any>response_);
                } catch (e) {
                    return <Observable<TermsAndPolicyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TermsAndPolicyDto>><any>_observableThrow(response_);
        }));
    }

    protected processSetTermsAndPolicy(response: HttpResponseBase): Observable<TermsAndPolicyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TermsAndPolicyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TermsAndPolicyDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAbout(): Observable<AboutDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientAppConfig/GetAbout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAbout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAbout(<any>response_);
                } catch (e) {
                    return <Observable<AboutDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AboutDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAbout(response: HttpResponseBase): Observable<AboutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AboutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AboutDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setAbout(body: CreateAboutDto | undefined): Observable<AboutDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientAppConfig/SetAbout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAbout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAbout(<any>response_);
                } catch (e) {
                    return <Observable<AboutDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AboutDto>><any>_observableThrow(response_);
        }));
    }

    protected processSetAbout(response: HttpResponseBase): Observable<AboutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AboutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AboutDto>(<any>null);
    }
}

@Injectable()
export class CompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CompanyDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CompanyDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCompanyDto | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCompanyDto | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CompanyDriversReuestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CompanyDriversReuestDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyDriversReuests/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDriversReuestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDriversReuestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CompanyDriversReuestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDriversReuestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDriversReuestDto>(<any>null);
    }

    /**
     * @param subcategoryId (optional) 
     * @param categoryId (optional) 
     * @param companyId (optional) 
     * @param keyWord (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(subcategoryId: number | undefined, categoryId: number | undefined, companyId: number | undefined, keyWord: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CompanyDriversReuestDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyDriversReuests/GetAll?";
        if (subcategoryId === null)
            throw new Error("The parameter 'subcategoryId' cannot be null.");
        else if (subcategoryId !== undefined)
            url_ += "SubcategoryId=" + encodeURIComponent("" + subcategoryId) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (keyWord === null)
            throw new Error("The parameter 'keyWord' cannot be null.");
        else if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDriversReuestDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDriversReuestDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CompanyDriversReuestDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDriversReuestDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDriversReuestDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CompanyDriversReuestDto | undefined): Observable<CompanyDriversReuestDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyDriversReuests/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDriversReuestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDriversReuestDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CompanyDriversReuestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDriversReuestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDriversReuestDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CompanyDriversReuestDto | undefined): Observable<CompanyDriversReuestDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyDriversReuests/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDriversReuestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDriversReuestDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CompanyDriversReuestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDriversReuestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDriversReuestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CompanyDriversReuests/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CouponServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateCoupon(body: ValidateCouponInput | undefined): Observable<MessageModel> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/ValidateCoupon";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateCoupon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateCoupon(<any>response_);
                } catch (e) {
                    return <Observable<MessageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageModel>><any>_observableThrow(response_);
        }));
    }

    protected processValidateCoupon(response: HttpResponseBase): Observable<MessageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CouponDto> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CouponDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CouponDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CouponDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param couponType (optional) 
     * @param value (optional) 
     * @param active (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, couponType: CouponTypes | undefined, value: number | undefined, active: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CouponDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (couponType === null)
            throw new Error("The parameter 'couponType' cannot be null.");
        else if (couponType !== undefined)
            url_ += "CouponType=" + encodeURIComponent("" + couponType) + "&";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "Value=" + encodeURIComponent("" + value) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CouponDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CouponDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CouponDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCouponDto | undefined): Observable<CouponDto> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CouponDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CouponDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CouponDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCouponDto | undefined): Observable<CouponDto> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CouponDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CouponDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CouponDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DriverServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getProfile(): Observable<DriverDto> {
        let url_ = this.baseUrl + "/api/services/app/Driver/GetProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfile(<any>response_);
                } catch (e) {
                    return <Observable<DriverDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DriverDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfile(response: HttpResponseBase): Observable<DriverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProfile(body: CreateDriverDto | undefined): Observable<DriverDto> {
        let url_ = this.baseUrl + "/api/services/app/Driver/CreateProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProfile(<any>response_);
                } catch (e) {
                    return <Observable<DriverDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DriverDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProfile(response: HttpResponseBase): Observable<DriverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfile(body: UpdateDriverDto | undefined): Observable<DriverDto> {
        let url_ = this.baseUrl + "/api/services/app/Driver/UpdateProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfile(<any>response_);
                } catch (e) {
                    return <Observable<DriverDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DriverDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfile(response: HttpResponseBase): Observable<DriverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDriverLocation(body: UpdateDriverLocationInput | undefined): Observable<MessageModel> {
        let url_ = this.baseUrl + "/api/services/app/Driver/UpdateDriverLocation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDriverLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDriverLocation(<any>response_);
                } catch (e) {
                    return <Observable<MessageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDriverLocation(response: HttpResponseBase): Observable<MessageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageModel>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    isHasClientProfile(userId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Driver/IsHasClientProfile?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsHasClientProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsHasClientProfile(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsHasClientProfile(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    isHasCompanyClientProfile(userId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Driver/IsHasCompanyClientProfile?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsHasCompanyClientProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsHasCompanyClientProfile(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsHasCompanyClientProfile(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param offDuty (optional) 
     * @return Success
     */
    setDriverOffDuty(userId: number | undefined, offDuty: boolean | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Driver/SetDriverOffDuty?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (offDuty === null)
            throw new Error("The parameter 'offDuty' cannot be null.");
        else if (offDuty !== undefined)
            url_ += "offDuty=" + encodeURIComponent("" + offDuty) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDriverOffDuty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDriverOffDuty(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSetDriverOffDuty(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    geNearestDrivers(body: GeNearestDriversInput | undefined): Observable<DriverDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Driver/GeNearestDrivers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeNearestDrivers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeNearestDrivers(<any>response_);
                } catch (e) {
                    return <Observable<DriverDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DriverDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGeNearestDrivers(response: HttpResponseBase): Observable<DriverDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverDtoPagedResultDto>(<any>null);
    }

    /**
     * @param latitude (optional) 
     * @param longitude (optional) 
     * @param horizontalAccuracy (optional) 
     * @param verticalAccuracy (optional) 
     * @param speed (optional) 
     * @param course (optional) 
     * @param isUnknown (optional) 
     * @param altitude (optional) 
     * @param lat (optional) 
     * @param long (optional) 
     * @return Success
     */
    getdistance(latitude: number | undefined, longitude: number | undefined, horizontalAccuracy: number | undefined, verticalAccuracy: number | undefined, speed: number | undefined, course: number | undefined, isUnknown: boolean | undefined, altitude: number | undefined, lat: number | undefined, long: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Driver/getdistance?";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "Latitude=" + encodeURIComponent("" + latitude) + "&";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "Longitude=" + encodeURIComponent("" + longitude) + "&";
        if (horizontalAccuracy === null)
            throw new Error("The parameter 'horizontalAccuracy' cannot be null.");
        else if (horizontalAccuracy !== undefined)
            url_ += "HorizontalAccuracy=" + encodeURIComponent("" + horizontalAccuracy) + "&";
        if (verticalAccuracy === null)
            throw new Error("The parameter 'verticalAccuracy' cannot be null.");
        else if (verticalAccuracy !== undefined)
            url_ += "VerticalAccuracy=" + encodeURIComponent("" + verticalAccuracy) + "&";
        if (speed === null)
            throw new Error("The parameter 'speed' cannot be null.");
        else if (speed !== undefined)
            url_ += "Speed=" + encodeURIComponent("" + speed) + "&";
        if (course === null)
            throw new Error("The parameter 'course' cannot be null.");
        else if (course !== undefined)
            url_ += "Course=" + encodeURIComponent("" + course) + "&";
        if (isUnknown === null)
            throw new Error("The parameter 'isUnknown' cannot be null.");
        else if (isUnknown !== undefined)
            url_ += "IsUnknown=" + encodeURIComponent("" + isUnknown) + "&";
        if (altitude === null)
            throw new Error("The parameter 'altitude' cannot be null.");
        else if (altitude !== undefined)
            url_ += "Altitude=" + encodeURIComponent("" + altitude) + "&";
        if (lat === null)
            throw new Error("The parameter 'lat' cannot be null.");
        else if (lat !== undefined)
            url_ += "Lat=" + encodeURIComponent("" + lat) + "&";
        if (long === null)
            throw new Error("The parameter 'long' cannot be null.");
        else if (long !== undefined)
            url_ += "Long=" + encodeURIComponent("" + long) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdistance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdistance(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetdistance(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DriverDto> {
        let url_ = this.baseUrl + "/api/services/app/Driver/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DriverDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DriverDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DriverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DriverDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Driver/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DriverDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DriverDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DriverDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateDriverDto | undefined): Observable<DriverDto> {
        let url_ = this.baseUrl + "/api/services/app/Driver/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DriverDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DriverDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DriverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateDriverDto | undefined): Observable<DriverDto> {
        let url_ = this.baseUrl + "/api/services/app/Driver/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<DriverDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DriverDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DriverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Driver/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DriverJoinRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DriverJoinRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverJoinRequest/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DriverJoinRequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DriverJoinRequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DriverJoinRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverJoinRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverJoinRequestDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DriverJoinRequestDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverJoinRequest/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DriverJoinRequestDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DriverJoinRequestDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DriverJoinRequestDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverJoinRequestDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverJoinRequestDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AdminCreateDriverJoinRequestDto | undefined): Observable<DriverJoinRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverJoinRequest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DriverJoinRequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DriverJoinRequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DriverJoinRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverJoinRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverJoinRequestDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AdminUpdateDriverJoinRequestDto | undefined): Observable<DriverJoinRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverJoinRequest/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<DriverJoinRequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DriverJoinRequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DriverJoinRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverJoinRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverJoinRequestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DriverJoinRequest/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setUserFireToken(body: SetUserFireTokenDto | undefined): Observable<UserFireTokenDto> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetUserFireToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetUserFireToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetUserFireToken(<any>response_);
                } catch (e) {
                    return <Observable<UserFireTokenDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserFireTokenDto>><any>_observableThrow(response_);
        }));
    }

    protected processSetUserFireToken(response: HttpResponseBase): Observable<UserFireTokenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserFireTokenDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserFireTokenDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendClientNotification(body: SendClientNotificationDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SendClientNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendClientNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendClientNotification(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSendClientNotification(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class OfferPriceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param offerPriceId (optional) 
     * @return Success
     */
    getClientRequestWOfferPrice(offerPriceId: number | undefined): Observable<RequestWOfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/GetClientRequestWOfferPrice?";
        if (offerPriceId === null)
            throw new Error("The parameter 'offerPriceId' cannot be null.");
        else if (offerPriceId !== undefined)
            url_ += "offerPriceId=" + encodeURIComponent("" + offerPriceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientRequestWOfferPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientRequestWOfferPrice(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientRequestWOfferPrice(response: HttpResponseBase): Observable<RequestWOfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDto>(<any>null);
    }

    /**
     * @param requestId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getClientRequestOfferPrices(requestId: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RequestWOfferPriceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/GetClientRequestOfferPrices?";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "RequestId=" + encodeURIComponent("" + requestId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientRequestOfferPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientRequestOfferPrices(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientRequestOfferPrices(response: HttpResponseBase): Observable<RequestWOfferPriceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDtoPagedResultDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getClientNotifOfferPrices(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RequestWOfferPriceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/GetClientNotifOfferPrices?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientNotifOfferPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientNotifOfferPrices(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientNotifOfferPrices(response: HttpResponseBase): Observable<RequestWOfferPriceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    makeDriverOfferPrice(body: CreateOfferPriceDto | undefined): Observable<RequestWOfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/MakeDriverOfferPrice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMakeDriverOfferPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMakeDriverOfferPrice(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processMakeDriverOfferPrice(response: HttpResponseBase): Observable<RequestWOfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDto>(<any>null);
    }

    /**
     * @param offerPriceId (optional) 
     * @return Success
     */
    clientMarkOfferPriceRead(offerPriceId: number | undefined): Observable<RequestWOfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/ClientMarkOfferPriceRead?";
        if (offerPriceId === null)
            throw new Error("The parameter 'offerPriceId' cannot be null.");
        else if (offerPriceId !== undefined)
            url_ += "offerPriceId=" + encodeURIComponent("" + offerPriceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientMarkOfferPriceRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientMarkOfferPriceRead(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processClientMarkOfferPriceRead(response: HttpResponseBase): Observable<RequestWOfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDto>(<any>null);
    }

    /**
     * @param notId (optional) 
     * @return Success
     */
    driverMarkOfferPriceRead(notId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/DriverMarkOfferPriceRead?";
        if (notId === null)
            throw new Error("The parameter 'notId' cannot be null.");
        else if (notId !== undefined)
            url_ += "NotId=" + encodeURIComponent("" + notId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriverMarkOfferPriceRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriverMarkOfferPriceRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDriverMarkOfferPriceRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param offerPriceId (optional) 
     * @return Success
     */
    acceptClientOfferPrice(offerPriceId: number | undefined): Observable<RequestWOfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/AcceptClientOfferPrice?";
        if (offerPriceId === null)
            throw new Error("The parameter 'offerPriceId' cannot be null.");
        else if (offerPriceId !== undefined)
            url_ += "offerPriceId=" + encodeURIComponent("" + offerPriceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptClientOfferPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptClientOfferPrice(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptClientOfferPrice(response: HttpResponseBase): Observable<RequestWOfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rateDriverByOffer(body: RateDriverByOfferDto | undefined): Observable<RequestWOfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/RateDriverByOffer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateDriverByOffer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateDriverByOffer(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processRateDriverByOffer(response: HttpResponseBase): Observable<RequestWOfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rateDriverByRequest(body: RateDriverByRequestDto | undefined): Observable<RequestWOfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/RateDriverByRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateDriverByRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateDriverByRequest(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processRateDriverByRequest(response: HttpResponseBase): Observable<RequestWOfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    driverOfferNewOfferPrice(body: CreateOfferPriceDto | undefined): Observable<RequestWOfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/DriverOfferNewOfferPrice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriverOfferNewOfferPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriverOfferNewOfferPrice(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processDriverOfferNewOfferPrice(response: HttpResponseBase): Observable<RequestWOfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientComanyOfferNewOfferPrice(body: CreateOfferPriceDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/ClientComanyOfferNewOfferPrice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientComanyOfferNewOfferPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientComanyOfferNewOfferPrice(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processClientComanyOfferNewOfferPrice(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getDrverRates(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RequestWOfferPriceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/GetDrverRates?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDrverRates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDrverRates(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDrverRates(response: HttpResponseBase): Observable<RequestWOfferPriceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDtoPagedResultDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getDriverCurrentRequests(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RequestWOfferPriceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/GetDriverCurrentRequests?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDriverCurrentRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDriverCurrentRequests(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDriverCurrentRequests(response: HttpResponseBase): Observable<RequestWOfferPriceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDtoPagedResultDto>(<any>null);
    }

    /**
     * @param offerStatus (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getDriverRequests(offerStatus: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RequestWOfferPriceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/GetDriverRequests?";
        if (offerStatus === null)
            throw new Error("The parameter 'offerStatus' cannot be null.");
        else if (offerStatus !== undefined)
            url_ += "OfferStatus=" + encodeURIComponent("" + offerStatus) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDriverRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDriverRequests(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDriverRequests(response: HttpResponseBase): Observable<RequestWOfferPriceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    driverChangeOfferPriceStatus(body: ChangeOfferPriceStatus | undefined): Observable<RequestWOfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/DriverChangeOfferPriceStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriverChangeOfferPriceStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriverChangeOfferPriceStatus(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processDriverChangeOfferPriceStatus(response: HttpResponseBase): Observable<RequestWOfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rateClientByOffer(body: RateDriverByOfferDto | undefined): Observable<RequestWOfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/RateClientByOffer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateClientByOffer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateClientByOffer(<any>response_);
                } catch (e) {
                    return <Observable<RequestWOfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestWOfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processRateClientByOffer(response: HttpResponseBase): Observable<RequestWOfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestWOfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestWOfferPriceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    offerPriceByRequestId(body: GetOfferPriceDto | undefined): Observable<OfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/OfferPriceByRequestId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOfferPriceByRequestId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOfferPriceByRequestId(<any>response_);
                } catch (e) {
                    return <Observable<OfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processOfferPriceByRequestId(response: HttpResponseBase): Observable<OfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferPriceDto>(<any>null);
    }

    /**
     * @param driverUserId (optional) 
     * @param driverId (optional) 
     * @param requestId (optional) 
     * @return Success
     */
    driverUpdateLocationNotification(driverUserId: number | undefined, driverId: number | undefined, requestId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/DriverUpdateLocationNotification?";
        if (driverUserId === null)
            throw new Error("The parameter 'driverUserId' cannot be null.");
        else if (driverUserId !== undefined)
            url_ += "DriverUserId=" + encodeURIComponent("" + driverUserId) + "&";
        if (driverId === null)
            throw new Error("The parameter 'driverId' cannot be null.");
        else if (driverId !== undefined)
            url_ += "DriverId=" + encodeURIComponent("" + driverId) + "&";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "RequestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriverUpdateLocationNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriverUpdateLocationNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDriverUpdateLocationNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<OfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<OfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferPriceDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<OfferPriceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<OfferPriceDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferPriceDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<OfferPriceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferPriceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferPriceDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateOfferPriceDto | undefined): Observable<OfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<OfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<OfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferPriceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateOfferPriceDto | undefined): Observable<OfferPriceDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<OfferPriceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferPriceDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<OfferPriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferPriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferPriceDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OfferPrice/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OfferPriceStatusServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllOfferPriceStatus(): Observable<OfferPriceStatusDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OfferPriceStatus/GetAllOfferPriceStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOfferPriceStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOfferPriceStatus(<any>response_);
                } catch (e) {
                    return <Observable<OfferPriceStatusDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferPriceStatusDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOfferPriceStatus(response: HttpResponseBase): Observable<OfferPriceStatusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OfferPriceStatusDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferPriceStatusDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<OfferPriceStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPriceStatus/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<OfferPriceStatusDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferPriceStatusDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OfferPriceStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferPriceStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferPriceStatusDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<OfferPriceStatusDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPriceStatus/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<OfferPriceStatusDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferPriceStatusDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<OfferPriceStatusDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferPriceStatusDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferPriceStatusDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateOfferPriceStatusDto | undefined): Observable<OfferPriceStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPriceStatus/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<OfferPriceStatusDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferPriceStatusDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<OfferPriceStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferPriceStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferPriceStatusDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateOfferPriceStatusDto | undefined): Observable<OfferPriceStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferPriceStatus/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<OfferPriceStatusDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferPriceStatusDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<OfferPriceStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferPriceStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferPriceStatusDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OfferPriceStatus/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmPayment(body: CreatePaymentDto | undefined): Observable<MessageModel> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ConfirmPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<MessageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageModel>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<MessageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPaymentDetails(id: number | undefined): Observable<PaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentDetails(<any>response_);
                } catch (e) {
                    return <Observable<PaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentDetails(response: HttpResponseBase): Observable<PaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hyperRequest(body: HyperRequestDto | undefined): Observable<CheckOutResponse> {
        let url_ = this.baseUrl + "/api/services/app/Payment/HyperRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHyperRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHyperRequest(<any>response_);
                } catch (e) {
                    return <Observable<CheckOutResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckOutResponse>><any>_observableThrow(response_);
        }));
    }

    protected processHyperRequest(response: HttpResponseBase): Observable<CheckOutResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckOutResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckOutResponse>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param usedCoupon (optional) 
     * @param clientName (optional) 
     * @param driverName (optional) 
     * @param cost (optional) 
     * @param requestId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, usedCoupon: boolean | undefined, clientName: string | undefined, driverName: string | undefined, cost: number | undefined, requestId: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PaymentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (usedCoupon === null)
            throw new Error("The parameter 'usedCoupon' cannot be null.");
        else if (usedCoupon !== undefined)
            url_ += "UsedCoupon=" + encodeURIComponent("" + usedCoupon) + "&";
        if (clientName === null)
            throw new Error("The parameter 'clientName' cannot be null.");
        else if (clientName !== undefined)
            url_ += "ClientName=" + encodeURIComponent("" + clientName) + "&";
        if (driverName === null)
            throw new Error("The parameter 'driverName' cannot be null.");
        else if (driverName !== undefined)
            url_ += "DriverName=" + encodeURIComponent("" + driverName) + "&";
        if (cost === null)
            throw new Error("The parameter 'cost' cannot be null.");
        else if (cost !== undefined)
            url_ += "Cost=" + encodeURIComponent("" + cost) + "&";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "RequestId=" + encodeURIComponent("" + requestId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PaymentDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaymentDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePaymentDto | undefined): Observable<PaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePaymentDto | undefined): Observable<PaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PaymentDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PaymentDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentDetail/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PaymentDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaymentDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentDetailDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PaymentDetailDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentDetail/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PaymentDetailDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentDetailDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaymentDetailDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDetailDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentDetailDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePaymentDetailDto | undefined): Observable<PaymentDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentDetail/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PaymentDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PaymentDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentDetailDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePaymentDetailDto | undefined): Observable<PaymentDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentDetail/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PaymentDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PaymentDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentDetailDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentDetail/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PlateTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPlateTypes(): Observable<PlateTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PlateTypes/GetAllPlateTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPlateTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPlateTypes(<any>response_);
                } catch (e) {
                    return <Observable<PlateTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlateTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPlateTypes(response: HttpResponseBase): Observable<PlateTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PlateTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlateTypeDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PlateTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/PlateTypes/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PlateTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlateTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PlateTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlateTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlateTypeDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PlateTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PlateTypes/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PlateTypeDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlateTypeDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PlateTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlateTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlateTypeDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePlateTypeDto | undefined): Observable<PlateTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/PlateTypes/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PlateTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlateTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PlateTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlateTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlateTypeDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePlateTypeDto | undefined): Observable<PlateTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/PlateTypes/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PlateTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlateTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PlateTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlateTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlateTypeDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PlateTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRequest(body: CreateRequestDto | undefined): Observable<RequestDto> {
        let url_ = this.baseUrl + "/api/services/app/Request/CreateRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRequest(<any>response_);
                } catch (e) {
                    return <Observable<RequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRequest(response: HttpResponseBase): Observable<RequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDto>(<any>null);
    }

    /**
     * @param requestId (optional) 
     * @return Success
     */
    getClientRequest(requestId: number | undefined): Observable<RequestDto> {
        let url_ = this.baseUrl + "/api/services/app/Request/GetClientRequest?";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "requestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientRequest(<any>response_);
                } catch (e) {
                    return <Observable<RequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientRequest(response: HttpResponseBase): Observable<RequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDto>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getClientRequests(status: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RequestDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Request/GetClientRequests?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientRequests(<any>response_);
                } catch (e) {
                    return <Observable<RequestDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientRequests(response: HttpResponseBase): Observable<RequestDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDtoPagedResultDto>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param userType (optional) 
     * @return Success
     */
    getRequests(status: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined, userType: UserType | undefined): Observable<RequestDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Request/GetRequests?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "userType=" + encodeURIComponent("" + userType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequests(<any>response_);
                } catch (e) {
                    return <Observable<RequestDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequests(response: HttpResponseBase): Observable<RequestDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDtoPagedResultDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getDriverNewRequests(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RequestDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Request/GetDriverNewRequests?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDriverNewRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDriverNewRequests(<any>response_);
                } catch (e) {
                    return <Observable<RequestDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDriverNewRequests(response: HttpResponseBase): Observable<RequestDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDtoPagedResultDto>(<any>null);
    }

    /**
     * @param requestId (optional) 
     * @return Success
     */
    getDriverNewRequest(requestId: number | undefined): Observable<RequestDto> {
        let url_ = this.baseUrl + "/api/services/app/Request/GetDriverNewRequest?";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "requestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDriverNewRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDriverNewRequest(<any>response_);
                } catch (e) {
                    return <Observable<RequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDriverNewRequest(response: HttpResponseBase): Observable<RequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rejectClientRequest(body: RejectClientRequestInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Request/RejectClientRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectClientRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectClientRequest(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRejectClientRequest(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param driverId (optional) 
     * @param requestId (optional) 
     * @return Success
     */
    reassign(driverId: number | undefined, requestId: number | undefined): Observable<MessageModel> {
        let url_ = this.baseUrl + "/api/services/app/Request/Reassign?";
        if (driverId === null)
            throw new Error("The parameter 'driverId' cannot be null.");
        else if (driverId !== undefined)
            url_ += "DriverId=" + encodeURIComponent("" + driverId) + "&";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "RequestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReassign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReassign(<any>response_);
                } catch (e) {
                    return <Observable<MessageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageModel>><any>_observableThrow(response_);
        }));
    }

    protected processReassign(response: HttpResponseBase): Observable<MessageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RequestDto> {
        let url_ = this.baseUrl + "/api/services/app/Request/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RequestDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Request/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RequestDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RequestDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRequestDto | undefined): Observable<RequestDto> {
        let url_ = this.baseUrl + "/api/services/app/Request/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateRquestDto | undefined): Observable<RequestDto> {
        let url_ = this.baseUrl + "/api/services/app/Request/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Request/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RequestStatusServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllRequestStatus(): Observable<RequestStateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RequestStatus/GetAllRequestStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRequestStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRequestStatus(<any>response_);
                } catch (e) {
                    return <Observable<RequestStateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestStateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRequestStatus(response: HttpResponseBase): Observable<RequestStateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RequestStateDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestStateDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RequestStateDto> {
        let url_ = this.baseUrl + "/api/services/app/RequestStatus/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RequestStateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestStateDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RequestStateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestStateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestStateDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RequestStateDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RequestStatus/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RequestStateDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestStateDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RequestStateDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestStateDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestStateDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRequestStateDto | undefined): Observable<RequestStateDto> {
        let url_ = this.baseUrl + "/api/services/app/RequestStatus/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RequestStateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestStateDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RequestStateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestStateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestStateDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateRequestStateDto | undefined): Observable<RequestStateDto> {
        let url_ = this.baseUrl + "/api/services/app/RequestStatus/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RequestStateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestStateDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RequestStateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestStateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestStateDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestStatus/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleListDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleListDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class SignalrNotificationHelperServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param senderUserName (optional) 
     * @param newClientMessage (optional) 
     * @return Success
     */
    publish_NewClient(senderUserName: string | undefined, newClientMessage: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SignalrNotificationHelper/Publish_NewClient?";
        if (senderUserName === null)
            throw new Error("The parameter 'senderUserName' cannot be null.");
        else if (senderUserName !== undefined)
            url_ += "senderUserName=" + encodeURIComponent("" + senderUserName) + "&";
        if (newClientMessage === null)
            throw new Error("The parameter 'newClientMessage' cannot be null.");
        else if (newClientMessage !== undefined)
            url_ += "newClientMessage=" + encodeURIComponent("" + newClientMessage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublish_NewClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublish_NewClient(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublish_NewClient(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SubategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param categoryId (optional) 
     * @return Success
     */
    getSubcategoriesByCategoryId(categoryId: number | undefined): Observable<SubcategoryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Subategory/GetSubcategoriesByCategoryId?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubcategoriesByCategoryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubcategoriesByCategoryId(<any>response_);
                } catch (e) {
                    return <Observable<SubcategoryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubcategoryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubcategoriesByCategoryId(response: HttpResponseBase): Observable<SubcategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubcategoryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubcategoryDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<SubcategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Subategory/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SubcategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubcategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SubcategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubcategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubcategoryDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SubcategoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Subategory/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SubcategoryDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubcategoryDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SubcategoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubcategoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubcategoryDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateSubcategoryDto | undefined): Observable<SubcategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Subategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<SubcategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubcategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SubcategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubcategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubcategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateSubcategoryDto | undefined): Observable<SubcategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Subategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SubcategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubcategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SubcategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubcategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubcategoryDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subategory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateAdmin(body: AuthenticateAdminModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateAdmin(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateAdmin(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateSendSms(body: AuthenticateByPhoneModel | undefined): Observable<ResultCodeSms> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateSendSms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateSendSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateSendSms(<any>response_);
                } catch (e) {
                    return <Observable<ResultCodeSms>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResultCodeSms>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateSendSms(response: HttpResponseBase): Observable<ResultCodeSms> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultCodeSms.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultCodeSms>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateClient(body: AuthenticateByPhoneConfirmModel | undefined): Observable<AuthenticateClientResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateClient(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateClientResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateClientResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateClient(response: HttpResponseBase): Observable<AuthenticateClientResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateClientResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateClientResultModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateDriver(body: AuthenticateByPhoneConfirmModel | undefined): Observable<AuthenticateDriverResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateDriver";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateDriver(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateDriver(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateDriverResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateDriverResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateDriver(response: HttpResponseBase): Observable<AuthenticateDriverResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateDriverResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateDriverResultModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCompanyClient(body: AdminCreateCompanyClientDto | undefined): Observable<AdminCompanyClientDto> {
        let url_ = this.baseUrl + "/api/TokenAuth/CreateCompanyClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCompanyClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCompanyClient(<any>response_);
                } catch (e) {
                    return <Observable<AdminCompanyClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminCompanyClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCompanyClient(response: HttpResponseBase): Observable<AdminCompanyClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminCompanyClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminCompanyClientDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCompanyClient(body: AdminUpdateCompanyClientDto | undefined): Observable<AdminCompanyClientDto> {
        let url_ = this.baseUrl + "/api/TokenAuth/UpdateCompanyClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCompanyClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCompanyClient(<any>response_);
                } catch (e) {
                    return <Observable<AdminCompanyClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminCompanyClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCompanyClient(response: HttpResponseBase): Observable<AdminCompanyClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminCompanyClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminCompanyClientDto>(<any>null);
    }
}

@Injectable()
export class TrackingTripServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param requestId (optional) 
     * @param driverId (optional) 
     * @param plate (optional) 
     * @param trackingTripId (optional) 
     * @return Success
     */
    getTrackingTrip(requestId: number | undefined, driverId: number | undefined, plate: string | undefined, trackingTripId: number | undefined): Observable<TrackingApiDto> {
        let url_ = this.baseUrl + "/api/services/app/TrackingTrip/GetTrackingTrip?";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "RequestId=" + encodeURIComponent("" + requestId) + "&";
        if (driverId === null)
            throw new Error("The parameter 'driverId' cannot be null.");
        else if (driverId !== undefined)
            url_ += "DriverId=" + encodeURIComponent("" + driverId) + "&";
        if (plate === null)
            throw new Error("The parameter 'plate' cannot be null.");
        else if (plate !== undefined)
            url_ += "Plate=" + encodeURIComponent("" + plate) + "&";
        if (trackingTripId === null)
            throw new Error("The parameter 'trackingTripId' cannot be null.");
        else if (trackingTripId !== undefined)
            url_ += "TrackingTripId=" + encodeURIComponent("" + trackingTripId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrackingTrip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrackingTrip(<any>response_);
                } catch (e) {
                    return <Observable<TrackingApiDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrackingApiDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrackingTrip(response: HttpResponseBase): Observable<TrackingApiDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrackingApiDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrackingApiDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TrackingTripDto> {
        let url_ = this.baseUrl + "/api/services/app/TrackingTrip/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TrackingTripDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrackingTripDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TrackingTripDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrackingTripDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrackingTripDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param trackingTripId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, trackingTripId: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TrackingTripDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TrackingTrip/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (trackingTripId === null)
            throw new Error("The parameter 'trackingTripId' cannot be null.");
        else if (trackingTripId !== undefined)
            url_ += "TrackingTripId=" + encodeURIComponent("" + trackingTripId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TrackingTripDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrackingTripDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TrackingTripDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrackingTripDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrackingTripDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTrackingTripDto | undefined): Observable<TrackingTripDto> {
        let url_ = this.baseUrl + "/api/services/app/TrackingTrip/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TrackingTripDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrackingTripDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TrackingTripDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrackingTripDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrackingTripDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateTrackingTripDto | undefined): Observable<TrackingTripDto> {
        let url_ = this.baseUrl + "/api/services/app/TrackingTrip/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TrackingTripDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrackingTripDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TrackingTripDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrackingTripDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrackingTripDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TrackingTrip/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @return Success
     */
    adminGetMessageUsers(): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/AdminGetMessageUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminGetMessageUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminGetMessageUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processAdminGetMessageUsers(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    adminGetSpUserMessages(userId: number | undefined): Observable<AdminMessageDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/AdminGetSpUserMessages?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminGetSpUserMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminGetSpUserMessages(<any>response_);
                } catch (e) {
                    return <Observable<AdminMessageDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminMessageDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processAdminGetSpUserMessages(response: HttpResponseBase): Observable<AdminMessageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AdminMessageDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminMessageDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adminSendMessage(body: AdminCreateMessageDto | undefined): Observable<AdminMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/User/AdminSendMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSendMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSendMessage(<any>response_);
                } catch (e) {
                    return <Observable<AdminMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdminMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processAdminSendMessage(response: HttpResponseBase): Observable<AdminMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminMessageDto>(<any>null);
    }

    /**
     * @return Success
     */
    getMessages(): Observable<MessageDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetMessages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessages(<any>response_);
                } catch (e) {
                    return <Observable<MessageDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMessages(response: HttpResponseBase): Observable<MessageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MessageDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendMessage(body: CreateMessageDto | undefined): Observable<MessageDto> {
        let url_ = this.baseUrl + "/api/services/app/User/SendMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMessage(<any>response_);
                } catch (e) {
                    return <Observable<MessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processSendMessage(response: HttpResponseBase): Observable<MessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param phone (optional) 
     * @return Success
     */
    updatePhone(phone: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdatePhone?";
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePhone(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePhone(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    logout(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userID (optional) 
     * @param roleName (optional) 
     * @return Success
     */
    getUserRoles(userID: number | undefined, roleName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserRoles?";
        if (userID === null)
            throw new Error("The parameter 'userID' cannot be null.");
        else if (userID !== undefined)
            url_ += "UserID=" + encodeURIComponent("" + userID) + "&";
        if (roleName === null)
            throw new Error("The parameter 'roleName' cannot be null.");
        else if (roleName !== undefined)
            url_ += "RoleName=" + encodeURIComponent("" + roleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRoles(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserRoles(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkUserRole(body: UserRoleDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/CheckUserRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUserRole(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckUserRole(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class WalletServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @param deriverId (optional) 
     * @param walletValue (optional) 
     * @return Success
     */
    getWalletValue(clientId: number | undefined, deriverId: number | undefined, walletValue: number | undefined): Observable<WalletDto> {
        let url_ = this.baseUrl + "/api/services/app/Wallet/GetWalletValue?";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (deriverId === null)
            throw new Error("The parameter 'deriverId' cannot be null.");
        else if (deriverId !== undefined)
            url_ += "DeriverId=" + encodeURIComponent("" + deriverId) + "&";
        if (walletValue === null)
            throw new Error("The parameter 'walletValue' cannot be null.");
        else if (walletValue !== undefined)
            url_ += "WalletValue=" + encodeURIComponent("" + walletValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWalletValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWalletValue(<any>response_);
                } catch (e) {
                    return <Observable<WalletDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WalletDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWalletValue(response: HttpResponseBase): Observable<WalletDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    recharge(body: RechargeInput | undefined): Observable<MessageModel> {
        let url_ = this.baseUrl + "/api/services/app/Wallet/Recharge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecharge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecharge(<any>response_);
                } catch (e) {
                    return <Observable<MessageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageModel>><any>_observableThrow(response_);
        }));
    }

    protected processRecharge(response: HttpResponseBase): Observable<MessageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<WalletDto> {
        let url_ = this.baseUrl + "/api/services/app/Wallet/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WalletDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WalletDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WalletDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<WalletDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Wallet/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<WalletDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WalletDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WalletDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWalletDto | undefined): Observable<WalletDto> {
        let url_ = this.baseUrl + "/api/services/app/Wallet/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<WalletDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WalletDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WalletDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateWalletDto | undefined): Observable<WalletDto> {
        let url_ = this.baseUrl + "/api/services/app/Wallet/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<WalletDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WalletDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WalletDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Wallet/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WaselServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    regTrip(body: TripRegVM | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WaselService/RegTrip";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegTrip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegTrip(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processRegTrip(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTrip(body: TripUpdateVM | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WaselService/UpdateTrip";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTrip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTrip(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTrip(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    regDriver(body: RegDriverVM | undefined): Observable<WaselResponseDTOC> {
        let url_ = this.baseUrl + "/api/services/app/WaselService/RegDriver";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegDriver(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegDriver(<any>response_);
                } catch (e) {
                    return <Observable<WaselResponseDTOC>><any>_observableThrow(e);
                }
            } else
                return <Observable<WaselResponseDTOC>><any>_observableThrow(response_);
        }));
    }

    protected processRegDriver(response: HttpResponseBase): Observable<WaselResponseDTOC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WaselResponseDTOC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WaselResponseDTOC>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    regVechile(body: VechileRegVm | undefined): Observable<WaselResponseDTOC> {
        let url_ = this.baseUrl + "/api/services/app/WaselService/RegVechile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegVechile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegVechile(<any>response_);
                } catch (e) {
                    return <Observable<WaselResponseDTOC>><any>_observableThrow(e);
                }
            } else
                return <Observable<WaselResponseDTOC>><any>_observableThrow(response_);
        }));
    }

    protected processRegVechile(response: HttpResponseBase): Observable<WaselResponseDTOC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WaselResponseDTOC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WaselResponseDTOC>(<any>null);
    }

    /**
     * @param isAdd (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(isAdd: boolean | undefined, body: FishVm | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WaselService/Save?";
        if (isAdd === null)
            throw new Error("The parameter 'isAdd' cannot be null.");
        else if (isAdd !== undefined)
            url_ += "isAdd=" + encodeURIComponent("" + isAdd) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param token (optional) 
     * @return Success
     */
    getById(id: string | undefined, token: string | undefined): Observable<FishVm> {
        let url_ = this.baseUrl + "/api/services/app/WaselService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<FishVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FishVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<FishVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FishVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FishVm>(<any>null);
    }

    /**
     * @param token (optional) 
     * @param body (optional) 
     * @return Success
     */
    findAll(token: string | undefined, body: FishVm | undefined): Observable<FishVm[]> {
        let url_ = this.baseUrl + "/api/services/app/WaselService/FindAll?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindAll(<any>response_);
                } catch (e) {
                    return <Observable<FishVm[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FishVm[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindAll(response: HttpResponseBase): Observable<FishVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FishVm.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FishVm[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param token (optional) 
     * @return Success
     */
    delete(id: string | undefined, token: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WaselService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string | undefined;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string | undefined;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    password: string | undefined;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    password: string | undefined;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class AdminCategoryDto implements IAdminCategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    displayName: string | undefined;
    displayDescription: string | undefined;
    image: string | undefined;
    id: number;

    constructor(data?: IAdminCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionFa = _data["descriptionFa"];
            this.displayName = _data["displayName"];
            this.displayDescription = _data["displayDescription"];
            this.image = _data["image"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionFa"] = this.descriptionFa;
        data["displayName"] = this.displayName;
        data["displayDescription"] = this.displayDescription;
        data["image"] = this.image;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminCategoryDto {
        const json = this.toJSON();
        let result = new AdminCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    displayName: string | undefined;
    displayDescription: string | undefined;
    image: string | undefined;
    id: number;
}

export class AdminCategoryDtoPagedResultDto implements IAdminCategoryDtoPagedResultDto {
    totalCount: number;
    items: AdminCategoryDto[] | undefined;

    constructor(data?: IAdminCategoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdminCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminCategoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCategoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AdminCategoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdminCategoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCategoryDtoPagedResultDto {
    totalCount: number;
    items: AdminCategoryDto[] | undefined;
}

export class AdminCreateCategoryDto implements IAdminCreateCategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;

    constructor(data?: IAdminCreateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionFa = _data["descriptionFa"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): AdminCreateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionFa"] = this.descriptionFa;
        data["image"] = this.image;
        return data; 
    }

    clone(): AdminCreateCategoryDto {
        const json = this.toJSON();
        let result = new AdminCreateCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCreateCategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
}

export class AdminUpdateCategoryDto implements IAdminUpdateCategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    id: number;

    constructor(data?: IAdminUpdateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionFa = _data["descriptionFa"];
            this.image = _data["image"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminUpdateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminUpdateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionFa"] = this.descriptionFa;
        data["image"] = this.image;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminUpdateCategoryDto {
        const json = this.toJSON();
        let result = new AdminUpdateCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IAdminUpdateCategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    id: number;
}

export class AdminCreateClientDto implements IAdminCreateClientDto {
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    companyId: number | undefined;
    walletValue: number;

    constructor(data?: IAdminCreateClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.picture = _data["picture"];
            this.companyId = _data["companyId"];
            this.walletValue = _data["walletValue"];
        }
    }

    static fromJS(data: any): AdminCreateClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreateClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["picture"] = this.picture;
        data["companyId"] = this.companyId;
        data["walletValue"] = this.walletValue;
        return data; 
    }

    clone(): AdminCreateClientDto {
        const json = this.toJSON();
        let result = new AdminCreateClientDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCreateClientDto {
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    companyId: number | undefined;
    walletValue: number;
}

export class AdminClientDto implements IAdminClientDto {
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    notificationsCount: number;
    companyId: number | undefined;
    companyName: string | undefined;
    userId: number;
    walletValue: number;
    isDeleted: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IAdminClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.picture = _data["picture"];
            this.notificationsCount = _data["notificationsCount"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.userId = _data["userId"];
            this.walletValue = _data["walletValue"];
            this.isDeleted = _data["isDeleted"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["picture"] = this.picture;
        data["notificationsCount"] = this.notificationsCount;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["userId"] = this.userId;
        data["walletValue"] = this.walletValue;
        data["isDeleted"] = this.isDeleted;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminClientDto {
        const json = this.toJSON();
        let result = new AdminClientDto();
        result.init(json);
        return result;
    }
}

export interface IAdminClientDto {
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    notificationsCount: number;
    companyId: number | undefined;
    companyName: string | undefined;
    userId: number;
    walletValue: number;
    isDeleted: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class AdminUpdateClientDto implements IAdminUpdateClientDto {
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    companyId: number | undefined;
    walletValue: number;
    isDeleted: boolean;
    id: number;

    constructor(data?: IAdminUpdateClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.picture = _data["picture"];
            this.companyId = _data["companyId"];
            this.walletValue = _data["walletValue"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminUpdateClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminUpdateClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["picture"] = this.picture;
        data["companyId"] = this.companyId;
        data["walletValue"] = this.walletValue;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminUpdateClientDto {
        const json = this.toJSON();
        let result = new AdminUpdateClientDto();
        result.init(json);
        return result;
    }
}

export interface IAdminUpdateClientDto {
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    companyId: number | undefined;
    walletValue: number;
    isDeleted: boolean;
    id: number;
}

export class AdminClientDtoPagedResultDto implements IAdminClientDtoPagedResultDto {
    totalCount: number;
    items: AdminClientDto[] | undefined;

    constructor(data?: IAdminClientDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdminClientDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminClientDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminClientDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AdminClientDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdminClientDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdminClientDtoPagedResultDto {
    totalCount: number;
    items: AdminClientDto[] | undefined;
}

export class AdminClientAdressDto implements IAdminClientAdressDto {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;
    id: number;

    constructor(data?: IAdminClientAdressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adress = _data["adress"];
            this.title = _data["title"];
            this.langLat = _data["langLat"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminClientAdressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminClientAdressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adress"] = this.adress;
        data["title"] = this.title;
        data["langLat"] = this.langLat;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminClientAdressDto {
        const json = this.toJSON();
        let result = new AdminClientAdressDto();
        result.init(json);
        return result;
    }
}

export interface IAdminClientAdressDto {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;
    id: number;
}

export class AdminClientAdressDtoPagedResultDto implements IAdminClientAdressDtoPagedResultDto {
    totalCount: number;
    items: AdminClientAdressDto[] | undefined;

    constructor(data?: IAdminClientAdressDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdminClientAdressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminClientAdressDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminClientAdressDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AdminClientAdressDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdminClientAdressDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdminClientAdressDtoPagedResultDto {
    totalCount: number;
    items: AdminClientAdressDto[] | undefined;
}

export class AdminCreateClientAdressDto implements IAdminCreateClientAdressDto {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;

    constructor(data?: IAdminCreateClientAdressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adress = _data["adress"];
            this.title = _data["title"];
            this.langLat = _data["langLat"];
        }
    }

    static fromJS(data: any): AdminCreateClientAdressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreateClientAdressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adress"] = this.adress;
        data["title"] = this.title;
        data["langLat"] = this.langLat;
        return data; 
    }

    clone(): AdminCreateClientAdressDto {
        const json = this.toJSON();
        let result = new AdminCreateClientAdressDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCreateClientAdressDto {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;
}

export class AdminUpdateClientAdressDto implements IAdminUpdateClientAdressDto {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;
    id: number;

    constructor(data?: IAdminUpdateClientAdressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adress = _data["adress"];
            this.title = _data["title"];
            this.langLat = _data["langLat"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminUpdateClientAdressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminUpdateClientAdressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adress"] = this.adress;
        data["title"] = this.title;
        data["langLat"] = this.langLat;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminUpdateClientAdressDto {
        const json = this.toJSON();
        let result = new AdminUpdateClientAdressDto();
        result.init(json);
        return result;
    }
}

export interface IAdminUpdateClientAdressDto {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;
    id: number;
}

export class AdminUpdateCompanyClientDto implements IAdminUpdateCompanyClientDto {
    phone: string | undefined;
    email: string | undefined;
    fullName: string | undefined;
    companyId: number;
    id: number;

    constructor(data?: IAdminUpdateCompanyClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.companyId = _data["companyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminUpdateCompanyClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminUpdateCompanyClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["companyId"] = this.companyId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminUpdateCompanyClientDto {
        const json = this.toJSON();
        let result = new AdminUpdateCompanyClientDto();
        result.init(json);
        return result;
    }
}

export interface IAdminUpdateCompanyClientDto {
    phone: string | undefined;
    email: string | undefined;
    fullName: string | undefined;
    companyId: number;
    id: number;
}

export class AdminCompanyClientDto implements IAdminCompanyClientDto {
    phone: string | undefined;
    email: string | undefined;
    fullName: string | undefined;
    companyId: number;
    id: number;

    constructor(data?: IAdminCompanyClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.companyId = _data["companyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminCompanyClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCompanyClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["companyId"] = this.companyId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminCompanyClientDto {
        const json = this.toJSON();
        let result = new AdminCompanyClientDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCompanyClientDto {
    phone: string | undefined;
    email: string | undefined;
    fullName: string | undefined;
    companyId: number;
    id: number;
}

export class AdminCompanyClientDtoPagedResultDto implements IAdminCompanyClientDtoPagedResultDto {
    totalCount: number;
    items: AdminCompanyClientDto[] | undefined;

    constructor(data?: IAdminCompanyClientDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdminCompanyClientDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminCompanyClientDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCompanyClientDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AdminCompanyClientDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdminCompanyClientDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCompanyClientDtoPagedResultDto {
    totalCount: number;
    items: AdminCompanyClientDto[] | undefined;
}

export class AdminCreateCompanyClientDto implements IAdminCreateCompanyClientDto {
    phone: string | undefined;
    email: string | undefined;
    fullName: string | undefined;
    companyId: number;

    constructor(data?: IAdminCreateCompanyClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): AdminCreateCompanyClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreateCompanyClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["companyId"] = this.companyId;
        return data; 
    }

    clone(): AdminCreateCompanyClientDto {
        const json = this.toJSON();
        let result = new AdminCreateCompanyClientDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCreateCompanyClientDto {
    phone: string | undefined;
    email: string | undefined;
    fullName: string | undefined;
    companyId: number;
}

export class AdminCreateWaselDriverDto implements IAdminCreateWaselDriverDto {
    identityNumber: string | undefined;
    dateOfBirthGregorian: string | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    email: string | undefined;

    constructor(data?: IAdminCreateWaselDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identityNumber = _data["identityNumber"];
            this.dateOfBirthGregorian = _data["dateOfBirthGregorian"];
            this.dateOfBirthHijri = _data["dateOfBirthHijri"];
            this.mobileNumber = _data["mobileNumber"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): AdminCreateWaselDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreateWaselDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identityNumber"] = this.identityNumber;
        data["dateOfBirthGregorian"] = this.dateOfBirthGregorian;
        data["dateOfBirthHijri"] = this.dateOfBirthHijri;
        data["mobileNumber"] = this.mobileNumber;
        data["email"] = this.email;
        return data; 
    }

    clone(): AdminCreateWaselDriverDto {
        const json = this.toJSON();
        let result = new AdminCreateWaselDriverDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCreateWaselDriverDto {
    identityNumber: string | undefined;
    dateOfBirthGregorian: string | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    email: string | undefined;
}

export class AdminCreateDriverDto implements IAdminCreateDriverDto {
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    isDriverAvilable: boolean;
    offDuty: boolean;
    phone: string | undefined;
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    companyId: number;
    isWaselDriver: boolean;
    isWaselVehicle: boolean;
    plateTypeId: number | undefined;
    walletValue: number;
    bankAccount: string | undefined;
    makePriceOffer: boolean;
    isReceiveOrder: boolean;

    constructor(data?: IAdminCreateDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleSequenceNumber = _data["vehicleSequenceNumber"];
            this.driverIdentityNumber = _data["driverIdentityNumber"];
            this.isDriverAvilable = _data["isDriverAvilable"];
            this.offDuty = _data["offDuty"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.vehicleType = _data["vehicleType"];
            this.dateOfBirthGregorian = _data["dateOfBirthGregorian"] ? moment(_data["dateOfBirthGregorian"].toString()) : <any>undefined;
            this.dateOfBirthHijri = _data["dateOfBirthHijri"];
            this.mobileNumber = _data["mobileNumber"];
            this.addressTitle = _data["addressTitle"];
            this.lat = _data["lat"];
            this.long = _data["long"];
            this.plate = _data["plate"];
            this.companyId = _data["companyId"];
            this.isWaselDriver = _data["isWaselDriver"];
            this.isWaselVehicle = _data["isWaselVehicle"];
            this.plateTypeId = _data["plateTypeId"];
            this.walletValue = _data["walletValue"];
            this.bankAccount = _data["bankAccount"];
            this.makePriceOffer = _data["makePriceOffer"];
            this.isReceiveOrder = _data["isReceiveOrder"];
        }
    }

    static fromJS(data: any): AdminCreateDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreateDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleSequenceNumber"] = this.vehicleSequenceNumber;
        data["driverIdentityNumber"] = this.driverIdentityNumber;
        data["isDriverAvilable"] = this.isDriverAvilable;
        data["offDuty"] = this.offDuty;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["vehicleType"] = this.vehicleType;
        data["dateOfBirthGregorian"] = this.dateOfBirthGregorian ? this.dateOfBirthGregorian.toISOString() : <any>undefined;
        data["dateOfBirthHijri"] = this.dateOfBirthHijri;
        data["mobileNumber"] = this.mobileNumber;
        data["addressTitle"] = this.addressTitle;
        data["lat"] = this.lat;
        data["long"] = this.long;
        data["plate"] = this.plate;
        data["companyId"] = this.companyId;
        data["isWaselDriver"] = this.isWaselDriver;
        data["isWaselVehicle"] = this.isWaselVehicle;
        data["plateTypeId"] = this.plateTypeId;
        data["walletValue"] = this.walletValue;
        data["bankAccount"] = this.bankAccount;
        data["makePriceOffer"] = this.makePriceOffer;
        data["isReceiveOrder"] = this.isReceiveOrder;
        return data; 
    }

    clone(): AdminCreateDriverDto {
        const json = this.toJSON();
        let result = new AdminCreateDriverDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCreateDriverDto {
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    isDriverAvilable: boolean;
    offDuty: boolean;
    phone: string | undefined;
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    companyId: number;
    isWaselDriver: boolean;
    isWaselVehicle: boolean;
    plateTypeId: number | undefined;
    walletValue: number;
    bankAccount: string | undefined;
    makePriceOffer: boolean;
    isReceiveOrder: boolean;
}

export class MessageModel implements IMessageModel {
    success: boolean;
    message: string | undefined;
    data: any | undefined;

    constructor(data?: IMessageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): MessageModel {
        data = typeof data === 'object' ? data : {};
        let result = new MessageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data;
        return data; 
    }

    clone(): MessageModel {
        const json = this.toJSON();
        let result = new MessageModel();
        result.init(json);
        return result;
    }
}

export interface IMessageModel {
    success: boolean;
    message: string | undefined;
    data: any | undefined;
}

export class AdminUpdateDriverDto implements IAdminUpdateDriverDto {
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    isDriverAvilable: boolean;
    offDuty: boolean;
    phone: string | undefined;
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    companyId: number;
    isWaselDriver: boolean;
    isWaselVehicle: boolean;
    plateTypeId: number | undefined;
    walletValue: number;
    bankAccount: string | undefined;
    makePriceOffer: boolean;
    isReceiveOrder: boolean;
    id: number;

    constructor(data?: IAdminUpdateDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleSequenceNumber = _data["vehicleSequenceNumber"];
            this.driverIdentityNumber = _data["driverIdentityNumber"];
            this.isDriverAvilable = _data["isDriverAvilable"];
            this.offDuty = _data["offDuty"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.vehicleType = _data["vehicleType"];
            this.dateOfBirthGregorian = _data["dateOfBirthGregorian"] ? moment(_data["dateOfBirthGregorian"].toString()) : <any>undefined;
            this.dateOfBirthHijri = _data["dateOfBirthHijri"];
            this.mobileNumber = _data["mobileNumber"];
            this.addressTitle = _data["addressTitle"];
            this.lat = _data["lat"];
            this.long = _data["long"];
            this.plate = _data["plate"];
            this.companyId = _data["companyId"];
            this.isWaselDriver = _data["isWaselDriver"];
            this.isWaselVehicle = _data["isWaselVehicle"];
            this.plateTypeId = _data["plateTypeId"];
            this.walletValue = _data["walletValue"];
            this.bankAccount = _data["bankAccount"];
            this.makePriceOffer = _data["makePriceOffer"];
            this.isReceiveOrder = _data["isReceiveOrder"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminUpdateDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminUpdateDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleSequenceNumber"] = this.vehicleSequenceNumber;
        data["driverIdentityNumber"] = this.driverIdentityNumber;
        data["isDriverAvilable"] = this.isDriverAvilable;
        data["offDuty"] = this.offDuty;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["vehicleType"] = this.vehicleType;
        data["dateOfBirthGregorian"] = this.dateOfBirthGregorian ? this.dateOfBirthGregorian.toISOString() : <any>undefined;
        data["dateOfBirthHijri"] = this.dateOfBirthHijri;
        data["mobileNumber"] = this.mobileNumber;
        data["addressTitle"] = this.addressTitle;
        data["lat"] = this.lat;
        data["long"] = this.long;
        data["plate"] = this.plate;
        data["companyId"] = this.companyId;
        data["isWaselDriver"] = this.isWaselDriver;
        data["isWaselVehicle"] = this.isWaselVehicle;
        data["plateTypeId"] = this.plateTypeId;
        data["walletValue"] = this.walletValue;
        data["bankAccount"] = this.bankAccount;
        data["makePriceOffer"] = this.makePriceOffer;
        data["isReceiveOrder"] = this.isReceiveOrder;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminUpdateDriverDto {
        const json = this.toJSON();
        let result = new AdminUpdateDriverDto();
        result.init(json);
        return result;
    }
}

export interface IAdminUpdateDriverDto {
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    isDriverAvilable: boolean;
    offDuty: boolean;
    phone: string | undefined;
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    companyId: number;
    isWaselDriver: boolean;
    isWaselVehicle: boolean;
    plateTypeId: number | undefined;
    walletValue: number;
    bankAccount: string | undefined;
    makePriceOffer: boolean;
    isReceiveOrder: boolean;
    id: number;
}

export class SubcategoryDto implements ISubcategoryDto {
    displayName: string | undefined;
    displayDescription: string | undefined;
    image: string | undefined;
    categoryId: number;
    id: number;

    constructor(data?: ISubcategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.displayDescription = _data["displayDescription"];
            this.image = _data["image"];
            this.categoryId = _data["categoryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubcategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubcategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["displayDescription"] = this.displayDescription;
        data["image"] = this.image;
        data["categoryId"] = this.categoryId;
        data["id"] = this.id;
        return data; 
    }

    clone(): SubcategoryDto {
        const json = this.toJSON();
        let result = new SubcategoryDto();
        result.init(json);
        return result;
    }
}

export interface ISubcategoryDto {
    displayName: string | undefined;
    displayDescription: string | undefined;
    image: string | undefined;
    categoryId: number;
    id: number;
}

export class DriverDto implements IDriverDto {
    isDriverAvilable: boolean;
    offDuty: boolean;
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    subCategory: SubcategoryDto;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    phone: string | undefined;
    companyId: number | undefined;
    notificationsCount: number;
    isWaselDriver: boolean;
    isWaselVehicle: boolean;
    plateTypeId: number | undefined;
    id: number;

    constructor(data?: IDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isDriverAvilable = _data["isDriverAvilable"];
            this.offDuty = _data["offDuty"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.vehicleType = _data["vehicleType"];
            this.subCategory = _data["subCategory"] ? SubcategoryDto.fromJS(_data["subCategory"]) : <any>undefined;
            this.dateOfBirthGregorian = _data["dateOfBirthGregorian"] ? moment(_data["dateOfBirthGregorian"].toString()) : <any>undefined;
            this.dateOfBirthHijri = _data["dateOfBirthHijri"];
            this.mobileNumber = _data["mobileNumber"];
            this.addressTitle = _data["addressTitle"];
            this.lat = _data["lat"];
            this.long = _data["long"];
            this.plate = _data["plate"];
            this.vehicleSequenceNumber = _data["vehicleSequenceNumber"];
            this.driverIdentityNumber = _data["driverIdentityNumber"];
            this.phone = _data["phone"];
            this.companyId = _data["companyId"];
            this.notificationsCount = _data["notificationsCount"];
            this.isWaselDriver = _data["isWaselDriver"];
            this.isWaselVehicle = _data["isWaselVehicle"];
            this.plateTypeId = _data["plateTypeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new DriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDriverAvilable"] = this.isDriverAvilable;
        data["offDuty"] = this.offDuty;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["vehicleType"] = this.vehicleType;
        data["subCategory"] = this.subCategory ? this.subCategory.toJSON() : <any>undefined;
        data["dateOfBirthGregorian"] = this.dateOfBirthGregorian ? this.dateOfBirthGregorian.toISOString() : <any>undefined;
        data["dateOfBirthHijri"] = this.dateOfBirthHijri;
        data["mobileNumber"] = this.mobileNumber;
        data["addressTitle"] = this.addressTitle;
        data["lat"] = this.lat;
        data["long"] = this.long;
        data["plate"] = this.plate;
        data["vehicleSequenceNumber"] = this.vehicleSequenceNumber;
        data["driverIdentityNumber"] = this.driverIdentityNumber;
        data["phone"] = this.phone;
        data["companyId"] = this.companyId;
        data["notificationsCount"] = this.notificationsCount;
        data["isWaselDriver"] = this.isWaselDriver;
        data["isWaselVehicle"] = this.isWaselVehicle;
        data["plateTypeId"] = this.plateTypeId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DriverDto {
        const json = this.toJSON();
        let result = new DriverDto();
        result.init(json);
        return result;
    }
}

export interface IDriverDto {
    isDriverAvilable: boolean;
    offDuty: boolean;
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    subCategory: SubcategoryDto;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    phone: string | undefined;
    companyId: number | undefined;
    notificationsCount: number;
    isWaselDriver: boolean;
    isWaselVehicle: boolean;
    plateTypeId: number | undefined;
    id: number;
}

export class WaselResponseDTOC implements IWaselResponseDTOC {
    success: boolean;
    resultCode: string | undefined;

    constructor(data?: IWaselResponseDTOC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.resultCode = _data["resultCode"];
        }
    }

    static fromJS(data: any): WaselResponseDTOC {
        data = typeof data === 'object' ? data : {};
        let result = new WaselResponseDTOC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["resultCode"] = this.resultCode;
        return data; 
    }

    clone(): WaselResponseDTOC {
        const json = this.toJSON();
        let result = new WaselResponseDTOC();
        result.init(json);
        return result;
    }
}

export interface IWaselResponseDTOC {
    success: boolean;
    resultCode: string | undefined;
}

export class SelectedDriver implements ISelectedDriver {
    id: number;
    name: string | undefined;
    readonly userId: number;

    constructor(data?: ISelectedDriver) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            (<any>this).userId = _data["userId"];
        }
    }

    static fromJS(data: any): SelectedDriver {
        data = typeof data === 'object' ? data : {};
        let result = new SelectedDriver();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): SelectedDriver {
        const json = this.toJSON();
        let result = new SelectedDriver();
        result.init(json);
        return result;
    }
}

export interface ISelectedDriver {
    id: number;
    name: string | undefined;
    userId: number;
}

export class AdminDriverDto implements IAdminDriverDto {
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    phone: string | undefined;
    isDriverAvilable: boolean;
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    subCategory: SubcategoryDto;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    companyId: number;
    companyName: string | undefined;
    offDuty: boolean;
    isWaselDriver: boolean;
    isWaselVehicle: boolean;
    plateTypeId: number | undefined;
    walletValue: number;
    bankAccount: string | undefined;
    makePriceOffer: boolean;
    isReceiveOrder: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IAdminDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleSequenceNumber = _data["vehicleSequenceNumber"];
            this.driverIdentityNumber = _data["driverIdentityNumber"];
            this.phone = _data["phone"];
            this.isDriverAvilable = _data["isDriverAvilable"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.vehicleType = _data["vehicleType"];
            this.subCategory = _data["subCategory"] ? SubcategoryDto.fromJS(_data["subCategory"]) : <any>undefined;
            this.dateOfBirthGregorian = _data["dateOfBirthGregorian"] ? moment(_data["dateOfBirthGregorian"].toString()) : <any>undefined;
            this.dateOfBirthHijri = _data["dateOfBirthHijri"];
            this.mobileNumber = _data["mobileNumber"];
            this.addressTitle = _data["addressTitle"];
            this.lat = _data["lat"];
            this.long = _data["long"];
            this.plate = _data["plate"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.offDuty = _data["offDuty"];
            this.isWaselDriver = _data["isWaselDriver"];
            this.isWaselVehicle = _data["isWaselVehicle"];
            this.plateTypeId = _data["plateTypeId"];
            this.walletValue = _data["walletValue"];
            this.bankAccount = _data["bankAccount"];
            this.makePriceOffer = _data["makePriceOffer"];
            this.isReceiveOrder = _data["isReceiveOrder"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleSequenceNumber"] = this.vehicleSequenceNumber;
        data["driverIdentityNumber"] = this.driverIdentityNumber;
        data["phone"] = this.phone;
        data["isDriverAvilable"] = this.isDriverAvilable;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["vehicleType"] = this.vehicleType;
        data["subCategory"] = this.subCategory ? this.subCategory.toJSON() : <any>undefined;
        data["dateOfBirthGregorian"] = this.dateOfBirthGregorian ? this.dateOfBirthGregorian.toISOString() : <any>undefined;
        data["dateOfBirthHijri"] = this.dateOfBirthHijri;
        data["mobileNumber"] = this.mobileNumber;
        data["addressTitle"] = this.addressTitle;
        data["lat"] = this.lat;
        data["long"] = this.long;
        data["plate"] = this.plate;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["offDuty"] = this.offDuty;
        data["isWaselDriver"] = this.isWaselDriver;
        data["isWaselVehicle"] = this.isWaselVehicle;
        data["plateTypeId"] = this.plateTypeId;
        data["walletValue"] = this.walletValue;
        data["bankAccount"] = this.bankAccount;
        data["makePriceOffer"] = this.makePriceOffer;
        data["isReceiveOrder"] = this.isReceiveOrder;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminDriverDto {
        const json = this.toJSON();
        let result = new AdminDriverDto();
        result.init(json);
        return result;
    }
}

export interface IAdminDriverDto {
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    phone: string | undefined;
    isDriverAvilable: boolean;
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    subCategory: SubcategoryDto;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    companyId: number;
    companyName: string | undefined;
    offDuty: boolean;
    isWaselDriver: boolean;
    isWaselVehicle: boolean;
    plateTypeId: number | undefined;
    walletValue: number;
    bankAccount: string | undefined;
    makePriceOffer: boolean;
    isReceiveOrder: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class AdminDriverDtoPagedResultDto implements IAdminDriverDtoPagedResultDto {
    totalCount: number;
    items: AdminDriverDto[] | undefined;

    constructor(data?: IAdminDriverDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdminDriverDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminDriverDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminDriverDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AdminDriverDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdminDriverDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdminDriverDtoPagedResultDto {
    totalCount: number;
    items: AdminDriverDto[] | undefined;
}

export class TopRequestSalesDriverDto implements ITopRequestSalesDriverDto {
    driverName: string | undefined;
    requestsCount: number;
    email: string | undefined;
    phone: string | undefined;
    companyName: string | undefined;
    id: number;

    constructor(data?: ITopRequestSalesDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.driverName = _data["driverName"];
            this.requestsCount = _data["requestsCount"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.companyName = _data["companyName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TopRequestSalesDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopRequestSalesDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["driverName"] = this.driverName;
        data["requestsCount"] = this.requestsCount;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["companyName"] = this.companyName;
        data["id"] = this.id;
        return data; 
    }

    clone(): TopRequestSalesDriverDto {
        const json = this.toJSON();
        let result = new TopRequestSalesDriverDto();
        result.init(json);
        return result;
    }
}

export interface ITopRequestSalesDriverDto {
    driverName: string | undefined;
    requestsCount: number;
    email: string | undefined;
    phone: string | undefined;
    companyName: string | undefined;
    id: number;
}

export class AdminOfferPriceDto implements IAdminOfferPriceDto {
    vat: number;
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    driverId: number;
    driverName: string | undefined;
    clientName: string | undefined;
    offerStatus: number;
    isRated: boolean | undefined;
    rate: number | undefined;
    isRead: boolean | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IAdminOfferPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vat = _data["vat"];
            this.deliveryCost = _data["deliveryCost"];
            this.awayFrom = _data["awayFrom"];
            this.deliveryThroughDays = _data["deliveryThroughDays"];
            this.deliveryThroughHours = _data["deliveryThroughHours"];
            this.deliveryThroughMinutes = _data["deliveryThroughMinutes"];
            this.deliveryThroughSeconds = _data["deliveryThroughSeconds"];
            this.requestId = _data["requestId"];
            this.driverId = _data["driverId"];
            this.driverName = _data["driverName"];
            this.clientName = _data["clientName"];
            this.offerStatus = _data["offerStatus"];
            this.isRated = _data["isRated"];
            this.rate = _data["rate"];
            this.isRead = _data["isRead"];
            this.isClientRated = _data["isClientRated"];
            this.clientRate = _data["clientRate"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminOfferPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminOfferPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vat"] = this.vat;
        data["deliveryCost"] = this.deliveryCost;
        data["awayFrom"] = this.awayFrom;
        data["deliveryThroughDays"] = this.deliveryThroughDays;
        data["deliveryThroughHours"] = this.deliveryThroughHours;
        data["deliveryThroughMinutes"] = this.deliveryThroughMinutes;
        data["deliveryThroughSeconds"] = this.deliveryThroughSeconds;
        data["requestId"] = this.requestId;
        data["driverId"] = this.driverId;
        data["driverName"] = this.driverName;
        data["clientName"] = this.clientName;
        data["offerStatus"] = this.offerStatus;
        data["isRated"] = this.isRated;
        data["rate"] = this.rate;
        data["isRead"] = this.isRead;
        data["isClientRated"] = this.isClientRated;
        data["clientRate"] = this.clientRate;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminOfferPriceDto {
        const json = this.toJSON();
        let result = new AdminOfferPriceDto();
        result.init(json);
        return result;
    }
}

export interface IAdminOfferPriceDto {
    vat: number;
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    driverId: number;
    driverName: string | undefined;
    clientName: string | undefined;
    offerStatus: number;
    isRated: boolean | undefined;
    rate: number | undefined;
    isRead: boolean | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class AdminOfferPriceDtoPagedResultDto implements IAdminOfferPriceDtoPagedResultDto {
    totalCount: number;
    items: AdminOfferPriceDto[] | undefined;

    constructor(data?: IAdminOfferPriceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdminOfferPriceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminOfferPriceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminOfferPriceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AdminOfferPriceDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdminOfferPriceDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdminOfferPriceDtoPagedResultDto {
    totalCount: number;
    items: AdminOfferPriceDto[] | undefined;
}

export class AdminCreateOfferPriceDto implements IAdminCreateOfferPriceDto {
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;

    constructor(data?: IAdminCreateOfferPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deliveryCost = _data["deliveryCost"];
            this.awayFrom = _data["awayFrom"];
            this.deliveryThroughDays = _data["deliveryThroughDays"];
            this.deliveryThroughHours = _data["deliveryThroughHours"];
            this.deliveryThroughMinutes = _data["deliveryThroughMinutes"];
            this.deliveryThroughSeconds = _data["deliveryThroughSeconds"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): AdminCreateOfferPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreateOfferPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryCost"] = this.deliveryCost;
        data["awayFrom"] = this.awayFrom;
        data["deliveryThroughDays"] = this.deliveryThroughDays;
        data["deliveryThroughHours"] = this.deliveryThroughHours;
        data["deliveryThroughMinutes"] = this.deliveryThroughMinutes;
        data["deliveryThroughSeconds"] = this.deliveryThroughSeconds;
        data["requestId"] = this.requestId;
        return data; 
    }

    clone(): AdminCreateOfferPriceDto {
        const json = this.toJSON();
        let result = new AdminCreateOfferPriceDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCreateOfferPriceDto {
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
}

export class AdminUpdateOfferPriceDto implements IAdminUpdateOfferPriceDto {
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    id: number;

    constructor(data?: IAdminUpdateOfferPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deliveryCost = _data["deliveryCost"];
            this.awayFrom = _data["awayFrom"];
            this.deliveryThroughDays = _data["deliveryThroughDays"];
            this.deliveryThroughHours = _data["deliveryThroughHours"];
            this.deliveryThroughMinutes = _data["deliveryThroughMinutes"];
            this.deliveryThroughSeconds = _data["deliveryThroughSeconds"];
            this.requestId = _data["requestId"];
            this.isClientRated = _data["isClientRated"];
            this.clientRate = _data["clientRate"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminUpdateOfferPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminUpdateOfferPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryCost"] = this.deliveryCost;
        data["awayFrom"] = this.awayFrom;
        data["deliveryThroughDays"] = this.deliveryThroughDays;
        data["deliveryThroughHours"] = this.deliveryThroughHours;
        data["deliveryThroughMinutes"] = this.deliveryThroughMinutes;
        data["deliveryThroughSeconds"] = this.deliveryThroughSeconds;
        data["requestId"] = this.requestId;
        data["isClientRated"] = this.isClientRated;
        data["clientRate"] = this.clientRate;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminUpdateOfferPriceDto {
        const json = this.toJSON();
        let result = new AdminUpdateOfferPriceDto();
        result.init(json);
        return result;
    }
}

export interface IAdminUpdateOfferPriceDto {
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    id: number;
}

export class AdminCreatePanelUserDto implements IAdminCreatePanelUserDto {
    username: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    companyId: number | undefined;
    roleNames: string[] | undefined;
    password: string | undefined;
    isActive: boolean;
    availableEditDelete: boolean;

    constructor(data?: IAdminCreatePanelUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
            this.isActive = _data["isActive"];
            this.availableEditDelete = _data["availableEditDelete"];
        }
    }

    static fromJS(data: any): AdminCreatePanelUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreatePanelUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["companyId"] = this.companyId;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["availableEditDelete"] = this.availableEditDelete;
        return data; 
    }

    clone(): AdminCreatePanelUserDto {
        const json = this.toJSON();
        let result = new AdminCreatePanelUserDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCreatePanelUserDto {
    username: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    companyId: number | undefined;
    roleNames: string[] | undefined;
    password: string | undefined;
    isActive: boolean;
    availableEditDelete: boolean;
}

export class RoleDto implements IRoleDto {
    name: string | undefined;
    displayName: string | undefined;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string | undefined;
    displayName: string | undefined;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;
}

export class AdminPanelUserDto implements IAdminPanelUserDto {
    username: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    password: string | undefined;
    availableEditDelete: boolean;
    companyId: number | undefined;
    role: RoleDto;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IAdminPanelUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.password = _data["password"];
            this.availableEditDelete = _data["availableEditDelete"];
            this.companyId = _data["companyId"];
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminPanelUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminPanelUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["password"] = this.password;
        data["availableEditDelete"] = this.availableEditDelete;
        data["companyId"] = this.companyId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminPanelUserDto {
        const json = this.toJSON();
        let result = new AdminPanelUserDto();
        result.init(json);
        return result;
    }
}

export interface IAdminPanelUserDto {
    username: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    password: string | undefined;
    availableEditDelete: boolean;
    companyId: number | undefined;
    role: RoleDto;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class AdminUpdatePanelUserDto implements IAdminUpdatePanelUserDto {
    username: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    password: string | undefined;
    availableEditDelete: boolean;
    companyId: number | undefined;
    roleNames: string[] | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IAdminUpdatePanelUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.password = _data["password"];
            this.availableEditDelete = _data["availableEditDelete"];
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminUpdatePanelUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminUpdatePanelUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["password"] = this.password;
        data["availableEditDelete"] = this.availableEditDelete;
        data["companyId"] = this.companyId;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminUpdatePanelUserDto {
        const json = this.toJSON();
        let result = new AdminUpdatePanelUserDto();
        result.init(json);
        return result;
    }
}

export interface IAdminUpdatePanelUserDto {
    username: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    password: string | undefined;
    availableEditDelete: boolean;
    companyId: number | undefined;
    roleNames: string[] | undefined;
    isActive: boolean;
    id: number;
}

export class AdminPanelUserDtoPagedResultDto implements IAdminPanelUserDtoPagedResultDto {
    totalCount: number;
    items: AdminPanelUserDto[] | undefined;

    constructor(data?: IAdminPanelUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdminPanelUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminPanelUserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminPanelUserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AdminPanelUserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdminPanelUserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdminPanelUserDtoPagedResultDto {
    totalCount: number;
    items: AdminPanelUserDto[] | undefined;
}

export class ClientDto implements IClientDto {
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    notificationsCount: number;
    companyId: number | undefined;
    id: number;

    constructor(data?: IClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.picture = _data["picture"];
            this.notificationsCount = _data["notificationsCount"];
            this.companyId = _data["companyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["picture"] = this.picture;
        data["notificationsCount"] = this.notificationsCount;
        data["companyId"] = this.companyId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ClientDto {
        const json = this.toJSON();
        let result = new ClientDto();
        result.init(json);
        return result;
    }
}

export interface IClientDto {
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    notificationsCount: number;
    companyId: number | undefined;
    id: number;
}

export class RequestDto implements IRequestDto {
    acceptedDriverName: string | undefined;
    net: number;
    vat: number;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    subcategoryDisplayName: string | undefined;
    status: number;
    deliveryCost: string | undefined;
    isRated: boolean | undefined;
    rate: number | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    receiverMobile: string | undefined;
    id: number;

    constructor(data?: IRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.acceptedDriverName = _data["acceptedDriverName"];
            this.net = _data["net"];
            this.vat = _data["vat"];
            this.discountPercentage = _data["discountPercentage"];
            this.arrivalDateTime = _data["arrivalDateTime"] ? moment(_data["arrivalDateTime"].toString()) : <any>undefined;
            this.paymentWay = _data["paymentWay"];
            this.notes = _data["notes"];
            this.startingPoint = _data["startingPoint"];
            this.endingPoint = _data["endingPoint"];
            this.stratingPointAdress = _data["stratingPointAdress"];
            this.stratingPointTitle = _data["stratingPointTitle"];
            this.endingPointAdress = _data["endingPointAdress"];
            this.endingPointTitle = _data["endingPointTitle"];
            this.subcategoryId = _data["subcategoryId"];
            this.subcategoryDisplayName = _data["subcategoryDisplayName"];
            this.status = _data["status"];
            this.deliveryCost = _data["deliveryCost"];
            this.isRated = _data["isRated"];
            this.rate = _data["rate"];
            this.isClientRated = _data["isClientRated"];
            this.clientRate = _data["clientRate"];
            this.receiverMobile = _data["receiverMobile"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acceptedDriverName"] = this.acceptedDriverName;
        data["net"] = this.net;
        data["vat"] = this.vat;
        data["discountPercentage"] = this.discountPercentage;
        data["arrivalDateTime"] = this.arrivalDateTime ? this.arrivalDateTime.toISOString() : <any>undefined;
        data["paymentWay"] = this.paymentWay;
        data["notes"] = this.notes;
        data["startingPoint"] = this.startingPoint;
        data["endingPoint"] = this.endingPoint;
        data["stratingPointAdress"] = this.stratingPointAdress;
        data["stratingPointTitle"] = this.stratingPointTitle;
        data["endingPointAdress"] = this.endingPointAdress;
        data["endingPointTitle"] = this.endingPointTitle;
        data["subcategoryId"] = this.subcategoryId;
        data["subcategoryDisplayName"] = this.subcategoryDisplayName;
        data["status"] = this.status;
        data["deliveryCost"] = this.deliveryCost;
        data["isRated"] = this.isRated;
        data["rate"] = this.rate;
        data["isClientRated"] = this.isClientRated;
        data["clientRate"] = this.clientRate;
        data["receiverMobile"] = this.receiverMobile;
        data["id"] = this.id;
        return data; 
    }

    clone(): RequestDto {
        const json = this.toJSON();
        let result = new RequestDto();
        result.init(json);
        return result;
    }
}

export interface IRequestDto {
    acceptedDriverName: string | undefined;
    net: number;
    vat: number;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    subcategoryDisplayName: string | undefined;
    status: number;
    deliveryCost: string | undefined;
    isRated: boolean | undefined;
    rate: number | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    receiverMobile: string | undefined;
    id: number;
}

export enum CouponTypes {
    _1 = 1,
    _2 = 2,
}

export class AdminPaymentDto implements IAdminPaymentDto {
    clientId: number;
    client: ClientDto;
    requestId: number;
    request: RequestDto;
    couponCode: string | undefined;
    couponType: CouponTypes;
    couponValue: number | undefined;
    cost: number;
    costAfterDiscount: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IAdminPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.client = _data["client"] ? ClientDto.fromJS(_data["client"]) : <any>undefined;
            this.requestId = _data["requestId"];
            this.request = _data["request"] ? RequestDto.fromJS(_data["request"]) : <any>undefined;
            this.couponCode = _data["couponCode"];
            this.couponType = _data["couponType"];
            this.couponValue = _data["couponValue"];
            this.cost = _data["cost"];
            this.costAfterDiscount = _data["costAfterDiscount"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["requestId"] = this.requestId;
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["couponCode"] = this.couponCode;
        data["couponType"] = this.couponType;
        data["couponValue"] = this.couponValue;
        data["cost"] = this.cost;
        data["costAfterDiscount"] = this.costAfterDiscount;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminPaymentDto {
        const json = this.toJSON();
        let result = new AdminPaymentDto();
        result.init(json);
        return result;
    }
}

export interface IAdminPaymentDto {
    clientId: number;
    client: ClientDto;
    requestId: number;
    request: RequestDto;
    couponCode: string | undefined;
    couponType: CouponTypes;
    couponValue: number | undefined;
    cost: number;
    costAfterDiscount: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class AdminPaymentDtoPagedResultDto implements IAdminPaymentDtoPagedResultDto {
    totalCount: number;
    items: AdminPaymentDto[] | undefined;

    constructor(data?: IAdminPaymentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdminPaymentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminPaymentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminPaymentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AdminPaymentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdminPaymentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdminPaymentDtoPagedResultDto {
    totalCount: number;
    items: AdminPaymentDto[] | undefined;
}

export class Trip implements ITrip {
    requestId: number;

    constructor(data?: ITrip) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): Trip {
        data = typeof data === 'object' ? data : {};
        let result = new Trip();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        return data; 
    }

    clone(): Trip {
        const json = this.toJSON();
        let result = new Trip();
        result.init(json);
        return result;
    }
}

export interface ITrip {
    requestId: number;
}

export class AdminCreateRequestDto implements IAdminCreateRequestDto {
    id: number;
    isReg: boolean | undefined;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    status: number;
    deliveryCost: string | undefined;
    receiverMobile: string | undefined;

    constructor(data?: IAdminCreateRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isReg = _data["isReg"];
            this.discountPercentage = _data["discountPercentage"];
            this.arrivalDateTime = _data["arrivalDateTime"] ? moment(_data["arrivalDateTime"].toString()) : <any>undefined;
            this.paymentWay = _data["paymentWay"];
            this.notes = _data["notes"];
            this.startingPoint = _data["startingPoint"];
            this.endingPoint = _data["endingPoint"];
            this.stratingPointAdress = _data["stratingPointAdress"];
            this.stratingPointTitle = _data["stratingPointTitle"];
            this.endingPointAdress = _data["endingPointAdress"];
            this.endingPointTitle = _data["endingPointTitle"];
            this.subcategoryId = _data["subcategoryId"];
            this.status = _data["status"];
            this.deliveryCost = _data["deliveryCost"];
            this.receiverMobile = _data["receiverMobile"];
        }
    }

    static fromJS(data: any): AdminCreateRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreateRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isReg"] = this.isReg;
        data["discountPercentage"] = this.discountPercentage;
        data["arrivalDateTime"] = this.arrivalDateTime ? this.arrivalDateTime.toISOString() : <any>undefined;
        data["paymentWay"] = this.paymentWay;
        data["notes"] = this.notes;
        data["startingPoint"] = this.startingPoint;
        data["endingPoint"] = this.endingPoint;
        data["stratingPointAdress"] = this.stratingPointAdress;
        data["stratingPointTitle"] = this.stratingPointTitle;
        data["endingPointAdress"] = this.endingPointAdress;
        data["endingPointTitle"] = this.endingPointTitle;
        data["subcategoryId"] = this.subcategoryId;
        data["status"] = this.status;
        data["deliveryCost"] = this.deliveryCost;
        data["receiverMobile"] = this.receiverMobile;
        return data; 
    }

    clone(): AdminCreateRequestDto {
        const json = this.toJSON();
        let result = new AdminCreateRequestDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCreateRequestDto {
    id: number;
    isReg: boolean | undefined;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    status: number;
    deliveryCost: string | undefined;
    receiverMobile: string | undefined;
}

export class ShortDriverDto implements IShortDriverDto {
    firstName: string | undefined;
    lastName: string | undefined;
    companyId: number | undefined;
    companyName: string | undefined;
    id: number;

    constructor(data?: IShortDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ShortDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShortDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["id"] = this.id;
        return data; 
    }

    clone(): ShortDriverDto {
        const json = this.toJSON();
        let result = new ShortDriverDto();
        result.init(json);
        return result;
    }
}

export interface IShortDriverDto {
    firstName: string | undefined;
    lastName: string | undefined;
    companyId: number | undefined;
    companyName: string | undefined;
    id: number;
}

export class ShortClientDto implements IShortClientDto {
    firstName: string | undefined;
    lastName: string | undefined;
    companyId: number | undefined;
    companyName: string | undefined;
    id: number;

    constructor(data?: IShortClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ShortClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShortClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["id"] = this.id;
        return data; 
    }

    clone(): ShortClientDto {
        const json = this.toJSON();
        let result = new ShortClientDto();
        result.init(json);
        return result;
    }
}

export interface IShortClientDto {
    firstName: string | undefined;
    lastName: string | undefined;
    companyId: number | undefined;
    companyName: string | undefined;
    id: number;
}

export class AdminRequestDto implements IAdminRequestDto {
    isReg: boolean | undefined;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    subcategoryDisplayName: string | undefined;
    status: number;
    requestStateName: string | undefined;
    deliveryCost: string | undefined;
    isRated: boolean | undefined;
    rate: number | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    driver: ShortDriverDto;
    creationTime: moment.Moment;
    ctString: string | undefined;
    acceptedDriverName: string | undefined;
    net: number;
    customerName: string | undefined;
    vat: number;
    vatAmount: number;
    client: ShortClientDto;
    receiverMobile: string | undefined;
    id: number;

    constructor(data?: IAdminRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isReg = _data["isReg"];
            this.discountPercentage = _data["discountPercentage"];
            this.arrivalDateTime = _data["arrivalDateTime"] ? moment(_data["arrivalDateTime"].toString()) : <any>undefined;
            this.paymentWay = _data["paymentWay"];
            this.notes = _data["notes"];
            this.startingPoint = _data["startingPoint"];
            this.endingPoint = _data["endingPoint"];
            this.stratingPointAdress = _data["stratingPointAdress"];
            this.stratingPointTitle = _data["stratingPointTitle"];
            this.endingPointAdress = _data["endingPointAdress"];
            this.endingPointTitle = _data["endingPointTitle"];
            this.subcategoryId = _data["subcategoryId"];
            this.subcategoryDisplayName = _data["subcategoryDisplayName"];
            this.status = _data["status"];
            this.requestStateName = _data["requestStateName"];
            this.deliveryCost = _data["deliveryCost"];
            this.isRated = _data["isRated"];
            this.rate = _data["rate"];
            this.isClientRated = _data["isClientRated"];
            this.clientRate = _data["clientRate"];
            this.driver = _data["driver"] ? ShortDriverDto.fromJS(_data["driver"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.ctString = _data["ctString"];
            this.acceptedDriverName = _data["acceptedDriverName"];
            this.net = _data["net"];
            this.customerName = _data["customerName"];
            this.vat = _data["vat"];
            this.vatAmount = _data["vatAmount"];
            this.client = _data["client"] ? ShortClientDto.fromJS(_data["client"]) : <any>undefined;
            this.receiverMobile = _data["receiverMobile"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isReg"] = this.isReg;
        data["discountPercentage"] = this.discountPercentage;
        data["arrivalDateTime"] = this.arrivalDateTime ? this.arrivalDateTime.toISOString() : <any>undefined;
        data["paymentWay"] = this.paymentWay;
        data["notes"] = this.notes;
        data["startingPoint"] = this.startingPoint;
        data["endingPoint"] = this.endingPoint;
        data["stratingPointAdress"] = this.stratingPointAdress;
        data["stratingPointTitle"] = this.stratingPointTitle;
        data["endingPointAdress"] = this.endingPointAdress;
        data["endingPointTitle"] = this.endingPointTitle;
        data["subcategoryId"] = this.subcategoryId;
        data["subcategoryDisplayName"] = this.subcategoryDisplayName;
        data["status"] = this.status;
        data["requestStateName"] = this.requestStateName;
        data["deliveryCost"] = this.deliveryCost;
        data["isRated"] = this.isRated;
        data["rate"] = this.rate;
        data["isClientRated"] = this.isClientRated;
        data["clientRate"] = this.clientRate;
        data["driver"] = this.driver ? this.driver.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["ctString"] = this.ctString;
        data["acceptedDriverName"] = this.acceptedDriverName;
        data["net"] = this.net;
        data["customerName"] = this.customerName;
        data["vat"] = this.vat;
        data["vatAmount"] = this.vatAmount;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["receiverMobile"] = this.receiverMobile;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminRequestDto {
        const json = this.toJSON();
        let result = new AdminRequestDto();
        result.init(json);
        return result;
    }
}

export interface IAdminRequestDto {
    isReg: boolean | undefined;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    subcategoryDisplayName: string | undefined;
    status: number;
    requestStateName: string | undefined;
    deliveryCost: string | undefined;
    isRated: boolean | undefined;
    rate: number | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    driver: ShortDriverDto;
    creationTime: moment.Moment;
    ctString: string | undefined;
    acceptedDriverName: string | undefined;
    net: number;
    customerName: string | undefined;
    vat: number;
    vatAmount: number;
    client: ShortClientDto;
    receiverMobile: string | undefined;
    id: number;
}

export class AdminUpdateRquestDto implements IAdminUpdateRquestDto {
    isReg: boolean | undefined;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    endingPoint: string | undefined;
    subcategoryId: number;
    status: number;
    deliveryCost: string | undefined;
    receiverMobile: string | undefined;
    id: number;

    constructor(data?: IAdminUpdateRquestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isReg = _data["isReg"];
            this.discountPercentage = _data["discountPercentage"];
            this.arrivalDateTime = _data["arrivalDateTime"] ? moment(_data["arrivalDateTime"].toString()) : <any>undefined;
            this.paymentWay = _data["paymentWay"];
            this.notes = _data["notes"];
            this.startingPoint = _data["startingPoint"];
            this.stratingPointAdress = _data["stratingPointAdress"];
            this.stratingPointTitle = _data["stratingPointTitle"];
            this.endingPointAdress = _data["endingPointAdress"];
            this.endingPointTitle = _data["endingPointTitle"];
            this.endingPoint = _data["endingPoint"];
            this.subcategoryId = _data["subcategoryId"];
            this.status = _data["status"];
            this.deliveryCost = _data["deliveryCost"];
            this.receiverMobile = _data["receiverMobile"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminUpdateRquestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminUpdateRquestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isReg"] = this.isReg;
        data["discountPercentage"] = this.discountPercentage;
        data["arrivalDateTime"] = this.arrivalDateTime ? this.arrivalDateTime.toISOString() : <any>undefined;
        data["paymentWay"] = this.paymentWay;
        data["notes"] = this.notes;
        data["startingPoint"] = this.startingPoint;
        data["stratingPointAdress"] = this.stratingPointAdress;
        data["stratingPointTitle"] = this.stratingPointTitle;
        data["endingPointAdress"] = this.endingPointAdress;
        data["endingPointTitle"] = this.endingPointTitle;
        data["endingPoint"] = this.endingPoint;
        data["subcategoryId"] = this.subcategoryId;
        data["status"] = this.status;
        data["deliveryCost"] = this.deliveryCost;
        data["receiverMobile"] = this.receiverMobile;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminUpdateRquestDto {
        const json = this.toJSON();
        let result = new AdminUpdateRquestDto();
        result.init(json);
        return result;
    }
}

export interface IAdminUpdateRquestDto {
    isReg: boolean | undefined;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    endingPoint: string | undefined;
    subcategoryId: number;
    status: number;
    deliveryCost: string | undefined;
    receiverMobile: string | undefined;
    id: number;
}

export class AdminCreateRequestWithOfferDto implements IAdminCreateRequestWithOfferDto {
    adminCreateRequestDto: AdminCreateRequestDto;
    adminOfferPriceDto: AdminOfferPriceDto;

    constructor(data?: IAdminCreateRequestWithOfferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminCreateRequestDto = _data["adminCreateRequestDto"] ? AdminCreateRequestDto.fromJS(_data["adminCreateRequestDto"]) : <any>undefined;
            this.adminOfferPriceDto = _data["adminOfferPriceDto"] ? AdminOfferPriceDto.fromJS(_data["adminOfferPriceDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdminCreateRequestWithOfferDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreateRequestWithOfferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminCreateRequestDto"] = this.adminCreateRequestDto ? this.adminCreateRequestDto.toJSON() : <any>undefined;
        data["adminOfferPriceDto"] = this.adminOfferPriceDto ? this.adminOfferPriceDto.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AdminCreateRequestWithOfferDto {
        const json = this.toJSON();
        let result = new AdminCreateRequestWithOfferDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCreateRequestWithOfferDto {
    adminCreateRequestDto: AdminCreateRequestDto;
    adminOfferPriceDto: AdminOfferPriceDto;
}

export class TopRequestSalesClientDto implements ITopRequestSalesClientDto {
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    requestsCount: number;
    id: number;

    constructor(data?: ITopRequestSalesClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.requestsCount = _data["requestsCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TopRequestSalesClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopRequestSalesClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["requestsCount"] = this.requestsCount;
        data["id"] = this.id;
        return data; 
    }

    clone(): TopRequestSalesClientDto {
        const json = this.toJSON();
        let result = new TopRequestSalesClientDto();
        result.init(json);
        return result;
    }
}

export interface ITopRequestSalesClientDto {
    phone: string | undefined;
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    requestsCount: number;
    id: number;
}

export class AdminRequestDtoPagedResultDto implements IAdminRequestDtoPagedResultDto {
    totalCount: number;
    items: AdminRequestDto[] | undefined;

    constructor(data?: IAdminRequestDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdminRequestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminRequestDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminRequestDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AdminRequestDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdminRequestDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdminRequestDtoPagedResultDto {
    totalCount: number;
    items: AdminRequestDto[] | undefined;
}

export class AdminSubcategoryDto implements IAdminSubcategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    displayName: string | undefined;
    displayDescription: string | undefined;
    image: string | undefined;
    categoryId: number;
    id: number;

    constructor(data?: IAdminSubcategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionFa = _data["descriptionFa"];
            this.displayName = _data["displayName"];
            this.displayDescription = _data["displayDescription"];
            this.image = _data["image"];
            this.categoryId = _data["categoryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminSubcategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminSubcategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionFa"] = this.descriptionFa;
        data["displayName"] = this.displayName;
        data["displayDescription"] = this.displayDescription;
        data["image"] = this.image;
        data["categoryId"] = this.categoryId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminSubcategoryDto {
        const json = this.toJSON();
        let result = new AdminSubcategoryDto();
        result.init(json);
        return result;
    }
}

export interface IAdminSubcategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    displayName: string | undefined;
    displayDescription: string | undefined;
    image: string | undefined;
    categoryId: number;
    id: number;
}

export class AdminSubcategoryDtoPagedResultDto implements IAdminSubcategoryDtoPagedResultDto {
    totalCount: number;
    items: AdminSubcategoryDto[] | undefined;

    constructor(data?: IAdminSubcategoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdminSubcategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminSubcategoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminSubcategoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AdminSubcategoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdminSubcategoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdminSubcategoryDtoPagedResultDto {
    totalCount: number;
    items: AdminSubcategoryDto[] | undefined;
}

export class AdminCreateSubcategoryDto implements IAdminCreateSubcategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    categoryId: number;

    constructor(data?: IAdminCreateSubcategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionFa = _data["descriptionFa"];
            this.image = _data["image"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): AdminCreateSubcategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreateSubcategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionFa"] = this.descriptionFa;
        data["image"] = this.image;
        data["categoryId"] = this.categoryId;
        return data; 
    }

    clone(): AdminCreateSubcategoryDto {
        const json = this.toJSON();
        let result = new AdminCreateSubcategoryDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCreateSubcategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    categoryId: number;
}

export class AdminUpdateSubcategoryDto implements IAdminUpdateSubcategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    categoryId: number;
    id: number;

    constructor(data?: IAdminUpdateSubcategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionFa = _data["descriptionFa"];
            this.image = _data["image"];
            this.categoryId = _data["categoryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminUpdateSubcategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminUpdateSubcategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionFa"] = this.descriptionFa;
        data["image"] = this.image;
        data["categoryId"] = this.categoryId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminUpdateSubcategoryDto {
        const json = this.toJSON();
        let result = new AdminUpdateSubcategoryDto();
        result.init(json);
        return result;
    }
}

export interface IAdminUpdateSubcategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    categoryId: number;
    id: number;
}

export class CreateAdminVechileDto implements ICreateAdminVechileDto {
    sequenceNumber: string | undefined;
    plate: string | undefined;
    plateType: number;

    constructor(data?: ICreateAdminVechileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sequenceNumber = _data["sequenceNumber"];
            this.plate = _data["plate"];
            this.plateType = _data["plateType"];
        }
    }

    static fromJS(data: any): CreateAdminVechileDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAdminVechileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sequenceNumber"] = this.sequenceNumber;
        data["plate"] = this.plate;
        data["plateType"] = this.plateType;
        return data; 
    }

    clone(): CreateAdminVechileDto {
        const json = this.toJSON();
        let result = new CreateAdminVechileDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAdminVechileDto {
    sequenceNumber: string | undefined;
    plate: string | undefined;
    plateType: number;
}

export class AdminVechileDto implements IAdminVechileDto {
    sequenceNumber: string | undefined;
    plate: string | undefined;
    plateType: number;
    plateTypeName: string | undefined;
    id: number;

    constructor(data?: IAdminVechileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sequenceNumber = _data["sequenceNumber"];
            this.plate = _data["plate"];
            this.plateType = _data["plateType"];
            this.plateTypeName = _data["plateTypeName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminVechileDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminVechileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sequenceNumber"] = this.sequenceNumber;
        data["plate"] = this.plate;
        data["plateType"] = this.plateType;
        data["plateTypeName"] = this.plateTypeName;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminVechileDto {
        const json = this.toJSON();
        let result = new AdminVechileDto();
        result.init(json);
        return result;
    }
}

export interface IAdminVechileDto {
    sequenceNumber: string | undefined;
    plate: string | undefined;
    plateType: number;
    plateTypeName: string | undefined;
    id: number;
}

export class AdminVechileDtoPagedResultDto implements IAdminVechileDtoPagedResultDto {
    totalCount: number;
    items: AdminVechileDto[] | undefined;

    constructor(data?: IAdminVechileDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdminVechileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminVechileDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminVechileDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AdminVechileDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdminVechileDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdminVechileDtoPagedResultDto {
    totalCount: number;
    items: AdminVechileDto[] | undefined;
}

export class UpdateAdminVechileDto implements IUpdateAdminVechileDto {
    sequenceNumber: string | undefined;
    plate: string | undefined;
    plateType: number;
    id: number;

    constructor(data?: IUpdateAdminVechileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sequenceNumber = _data["sequenceNumber"];
            this.plate = _data["plate"];
            this.plateType = _data["plateType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateAdminVechileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAdminVechileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sequenceNumber"] = this.sequenceNumber;
        data["plate"] = this.plate;
        data["plateType"] = this.plateType;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateAdminVechileDto {
        const json = this.toJSON();
        let result = new UpdateAdminVechileDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAdminVechileDto {
    sequenceNumber: string | undefined;
    plate: string | undefined;
    plateType: number;
    id: number;
}

export class AdminWaselDriverDto implements IAdminWaselDriverDto {
    identityNumber: string | undefined;
    dateOfBirthGregorian: string | undefined;
    mobileNumber: string | undefined;
    email: string | undefined;
    id: number;

    constructor(data?: IAdminWaselDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identityNumber = _data["identityNumber"];
            this.dateOfBirthGregorian = _data["dateOfBirthGregorian"];
            this.mobileNumber = _data["mobileNumber"];
            this.email = _data["email"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminWaselDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminWaselDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identityNumber"] = this.identityNumber;
        data["dateOfBirthGregorian"] = this.dateOfBirthGregorian;
        data["mobileNumber"] = this.mobileNumber;
        data["email"] = this.email;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminWaselDriverDto {
        const json = this.toJSON();
        let result = new AdminWaselDriverDto();
        result.init(json);
        return result;
    }
}

export interface IAdminWaselDriverDto {
    identityNumber: string | undefined;
    dateOfBirthGregorian: string | undefined;
    mobileNumber: string | undefined;
    email: string | undefined;
    id: number;
}

export class AdminWaselDriverDtoPagedResultDto implements IAdminWaselDriverDtoPagedResultDto {
    totalCount: number;
    items: AdminWaselDriverDto[] | undefined;

    constructor(data?: IAdminWaselDriverDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AdminWaselDriverDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminWaselDriverDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminWaselDriverDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AdminWaselDriverDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AdminWaselDriverDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAdminWaselDriverDtoPagedResultDto {
    totalCount: number;
    items: AdminWaselDriverDto[] | undefined;
}

export class AdminUpdateWaselDriverDto implements IAdminUpdateWaselDriverDto {
    identityNumber: string | undefined;
    dateOfBirthGregorian: string | undefined;
    mobileNumber: string | undefined;
    email: string | undefined;
    id: number;

    constructor(data?: IAdminUpdateWaselDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identityNumber = _data["identityNumber"];
            this.dateOfBirthGregorian = _data["dateOfBirthGregorian"];
            this.mobileNumber = _data["mobileNumber"];
            this.email = _data["email"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminUpdateWaselDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminUpdateWaselDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identityNumber"] = this.identityNumber;
        data["dateOfBirthGregorian"] = this.dateOfBirthGregorian;
        data["mobileNumber"] = this.mobileNumber;
        data["email"] = this.email;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminUpdateWaselDriverDto {
        const json = this.toJSON();
        let result = new AdminUpdateWaselDriverDto();
        result.init(json);
        return result;
    }
}

export interface IAdminUpdateWaselDriverDto {
    identityNumber: string | undefined;
    dateOfBirthGregorian: string | undefined;
    mobileNumber: string | undefined;
    email: string | undefined;
    id: number;
}

export class Company implements ICompany {
    name: string | undefined;
    nameAr: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    clients: Client[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            if (Array.isArray(_data["clients"])) {
                this.clients = [] as any;
                for (let item of _data["clients"])
                    this.clients.push(Client.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        if (Array.isArray(this.clients)) {
            data["clients"] = [];
            for (let item of this.clients)
                data["clients"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Company {
        const json = this.toJSON();
        let result = new Company();
        result.init(json);
        return result;
    }
}

export interface ICompany {
    name: string | undefined;
    nameAr: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    clients: Client[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Client implements IClient {
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    userId: number;
    user: User;
    companyId: number | undefined;
    company: Company;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IClient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.picture = _data["picture"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Client {
        data = typeof data === 'object' ? data : {};
        let result = new Client();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["picture"] = this.picture;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Client {
        const json = this.toJSON();
        let result = new Client();
        result.init(json);
        return result;
    }
}

export interface IClient {
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    userId: number;
    user: User;
    companyId: number | undefined;
    company: Company;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TrackingTrip implements ITrackingTrip {
    driverId: number;
    driver: Driver;
    requestId: number;
    request: Request;
    latitude: string | undefined;
    longitude: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITrackingTrip) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.driverId = _data["driverId"];
            this.driver = _data["driver"] ? Driver.fromJS(_data["driver"]) : <any>undefined;
            this.requestId = _data["requestId"];
            this.request = _data["request"] ? Request.fromJS(_data["request"]) : <any>undefined;
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TrackingTrip {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingTrip();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["driverId"] = this.driverId;
        data["driver"] = this.driver ? this.driver.toJSON() : <any>undefined;
        data["requestId"] = this.requestId;
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TrackingTrip {
        const json = this.toJSON();
        let result = new TrackingTrip();
        result.init(json);
        return result;
    }
}

export interface ITrackingTrip {
    driverId: number;
    driver: Driver;
    requestId: number;
    request: Request;
    latitude: string | undefined;
    longitude: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class PlateType implements IPlateType {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPlateType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PlateType {
        data = typeof data === 'object' ? data : {};
        let result = new PlateType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PlateType {
        const json = this.toJSON();
        let result = new PlateType();
        result.init(json);
        return result;
    }
}

export interface IPlateType {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Driver implements IDriver {
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    isDriverAvilable: boolean;
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    subCategory: Subcategory;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    userId: number;
    user: User;
    companyId: number | undefined;
    company: Company;
    offDuty: boolean;
    trackingTrips: TrackingTrip[] | undefined;
    isWaselDriver: boolean;
    bankAccount: string | undefined;
    makePriceOffer: boolean;
    isWaselVehicle: boolean;
    isReceiveOrder: boolean;
    plateTypeId: number | undefined;
    plateType: PlateType;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDriver) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleSequenceNumber = _data["vehicleSequenceNumber"];
            this.driverIdentityNumber = _data["driverIdentityNumber"];
            this.isDriverAvilable = _data["isDriverAvilable"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.vehicleType = _data["vehicleType"];
            this.subCategory = _data["subCategory"] ? Subcategory.fromJS(_data["subCategory"]) : <any>undefined;
            this.dateOfBirthGregorian = _data["dateOfBirthGregorian"] ? moment(_data["dateOfBirthGregorian"].toString()) : <any>undefined;
            this.dateOfBirthHijri = _data["dateOfBirthHijri"];
            this.mobileNumber = _data["mobileNumber"];
            this.addressTitle = _data["addressTitle"];
            this.lat = _data["lat"];
            this.long = _data["long"];
            this.plate = _data["plate"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.offDuty = _data["offDuty"];
            if (Array.isArray(_data["trackingTrips"])) {
                this.trackingTrips = [] as any;
                for (let item of _data["trackingTrips"])
                    this.trackingTrips.push(TrackingTrip.fromJS(item));
            }
            this.isWaselDriver = _data["isWaselDriver"];
            this.bankAccount = _data["bankAccount"];
            this.makePriceOffer = _data["makePriceOffer"];
            this.isWaselVehicle = _data["isWaselVehicle"];
            this.isReceiveOrder = _data["isReceiveOrder"];
            this.plateTypeId = _data["plateTypeId"];
            this.plateType = _data["plateType"] ? PlateType.fromJS(_data["plateType"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Driver {
        data = typeof data === 'object' ? data : {};
        let result = new Driver();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleSequenceNumber"] = this.vehicleSequenceNumber;
        data["driverIdentityNumber"] = this.driverIdentityNumber;
        data["isDriverAvilable"] = this.isDriverAvilable;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["vehicleType"] = this.vehicleType;
        data["subCategory"] = this.subCategory ? this.subCategory.toJSON() : <any>undefined;
        data["dateOfBirthGregorian"] = this.dateOfBirthGregorian ? this.dateOfBirthGregorian.toISOString() : <any>undefined;
        data["dateOfBirthHijri"] = this.dateOfBirthHijri;
        data["mobileNumber"] = this.mobileNumber;
        data["addressTitle"] = this.addressTitle;
        data["lat"] = this.lat;
        data["long"] = this.long;
        data["plate"] = this.plate;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["offDuty"] = this.offDuty;
        if (Array.isArray(this.trackingTrips)) {
            data["trackingTrips"] = [];
            for (let item of this.trackingTrips)
                data["trackingTrips"].push(item.toJSON());
        }
        data["isWaselDriver"] = this.isWaselDriver;
        data["bankAccount"] = this.bankAccount;
        data["makePriceOffer"] = this.makePriceOffer;
        data["isWaselVehicle"] = this.isWaselVehicle;
        data["isReceiveOrder"] = this.isReceiveOrder;
        data["plateTypeId"] = this.plateTypeId;
        data["plateType"] = this.plateType ? this.plateType.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Driver {
        const json = this.toJSON();
        let result = new Driver();
        result.init(json);
        return result;
    }
}

export interface IDriver {
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    isDriverAvilable: boolean;
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    subCategory: Subcategory;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    userId: number;
    user: User;
    companyId: number | undefined;
    company: Company;
    offDuty: boolean;
    trackingTrips: TrackingTrip[] | undefined;
    isWaselDriver: boolean;
    bankAccount: string | undefined;
    makePriceOffer: boolean;
    isWaselVehicle: boolean;
    isReceiveOrder: boolean;
    plateTypeId: number | undefined;
    plateType: PlateType;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class NotificationToken implements INotificationToken {
    userId: number;
    user: User;
    token: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: INotificationToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.token = _data["token"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NotificationToken {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["token"] = this.token;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): NotificationToken {
        const json = this.toJSON();
        let result = new NotificationToken();
        result.init(json);
        return result;
    }
}

export interface INotificationToken {
    userId: number;
    user: User;
    token: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ClientAdress implements IClientAdress {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;
    userId: number;
    user: User;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IClientAdress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adress = _data["adress"];
            this.title = _data["title"];
            this.langLat = _data["langLat"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClientAdress {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAdress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adress"] = this.adress;
        data["title"] = this.title;
        data["langLat"] = this.langLat;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ClientAdress {
        const json = this.toJSON();
        let result = new ClientAdress();
        result.init(json);
        return result;
    }
}

export interface IClientAdress {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;
    userId: number;
    user: User;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class NotificationLog implements INotificationLog {
    userId: number;
    user: User;
    notificationTitle: string | undefined;
    notificationBody: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: INotificationLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.notificationTitle = _data["notificationTitle"];
            this.notificationBody = _data["notificationBody"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NotificationLog {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["notificationTitle"] = this.notificationTitle;
        data["notificationBody"] = this.notificationBody;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): NotificationLog {
        const json = this.toJSON();
        let result = new NotificationLog();
        result.init(json);
        return result;
    }
}

export interface INotificationLog {
    userId: number;
    user: User;
    notificationTitle: string | undefined;
    notificationBody: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserToken implements IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;
}

export class UserLogin implements IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    providerKey: string | undefined;
    id: number;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    providerKey: string | undefined;
    id: number;
}

export class UserRole implements IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserClaim implements IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string | undefined;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string | undefined;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Setting implements ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string | undefined;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string | undefined;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class User implements IUser {
    client: Client;
    driver: Driver;
    notificationToken: NotificationToken;
    requests: Request[] | undefined;
    clientAdresses: ClientAdress[] | undefined;
    notificationLogs: NotificationLog[] | undefined;
    normalizedUserName: string | undefined;
    normalizedEmailAddress: string | undefined;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string | undefined;
    tenantId: number | undefined;
    emailAddress: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    readonly fullName: string | undefined;
    password: string | undefined;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.client = _data["client"] ? Client.fromJS(_data["client"]) : <any>undefined;
            this.driver = _data["driver"] ? Driver.fromJS(_data["driver"]) : <any>undefined;
            this.notificationToken = _data["notificationToken"] ? NotificationToken.fromJS(_data["notificationToken"]) : <any>undefined;
            if (Array.isArray(_data["requests"])) {
                this.requests = [] as any;
                for (let item of _data["requests"])
                    this.requests.push(Request.fromJS(item));
            }
            if (Array.isArray(_data["clientAdresses"])) {
                this.clientAdresses = [] as any;
                for (let item of _data["clientAdresses"])
                    this.clientAdresses.push(ClientAdress.fromJS(item));
            }
            if (Array.isArray(_data["notificationLogs"])) {
                this.notificationLogs = [] as any;
                for (let item of _data["notificationLogs"])
                    this.notificationLogs.push(NotificationLog.fromJS(item));
            }
            this.normalizedUserName = _data["normalizedUserName"];
            this.normalizedEmailAddress = _data["normalizedEmailAddress"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? moment(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["driver"] = this.driver ? this.driver.toJSON() : <any>undefined;
        data["notificationToken"] = this.notificationToken ? this.notificationToken.toJSON() : <any>undefined;
        if (Array.isArray(this.requests)) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        if (Array.isArray(this.clientAdresses)) {
            data["clientAdresses"] = [];
            for (let item of this.clientAdresses)
                data["clientAdresses"].push(item.toJSON());
        }
        if (Array.isArray(this.notificationLogs)) {
            data["notificationLogs"] = [];
            for (let item of this.notificationLogs)
                data["notificationLogs"].push(item.toJSON());
        }
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    client: Client;
    driver: Driver;
    notificationToken: NotificationToken;
    requests: Request[] | undefined;
    clientAdresses: ClientAdress[] | undefined;
    notificationLogs: NotificationLog[] | undefined;
    normalizedUserName: string | undefined;
    normalizedEmailAddress: string | undefined;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string | undefined;
    tenantId: number | undefined;
    emailAddress: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    fullName: string | undefined;
    password: string | undefined;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class OfferPrice implements IOfferPrice {
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    isRead: boolean | undefined;
    isDriverRead: boolean | undefined;
    isRated: boolean | undefined;
    rate: number | undefined;
    isAccepted: boolean | undefined;
    offerStatus: number;
    driverName: string | undefined;
    clientName: string | undefined;
    deliveryCost: number;
    vat: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    request: Request;
    driverId: number;
    driver: User;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IOfferPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isClientRated = _data["isClientRated"];
            this.clientRate = _data["clientRate"];
            this.isRead = _data["isRead"];
            this.isDriverRead = _data["isDriverRead"];
            this.isRated = _data["isRated"];
            this.rate = _data["rate"];
            this.isAccepted = _data["isAccepted"];
            this.offerStatus = _data["offerStatus"];
            this.driverName = _data["driverName"];
            this.clientName = _data["clientName"];
            this.deliveryCost = _data["deliveryCost"];
            this.vat = _data["vat"];
            this.awayFrom = _data["awayFrom"];
            this.deliveryThroughDays = _data["deliveryThroughDays"];
            this.deliveryThroughHours = _data["deliveryThroughHours"];
            this.deliveryThroughMinutes = _data["deliveryThroughMinutes"];
            this.deliveryThroughSeconds = _data["deliveryThroughSeconds"];
            this.requestId = _data["requestId"];
            this.request = _data["request"] ? Request.fromJS(_data["request"]) : <any>undefined;
            this.driverId = _data["driverId"];
            this.driver = _data["driver"] ? User.fromJS(_data["driver"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OfferPrice {
        data = typeof data === 'object' ? data : {};
        let result = new OfferPrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isClientRated"] = this.isClientRated;
        data["clientRate"] = this.clientRate;
        data["isRead"] = this.isRead;
        data["isDriverRead"] = this.isDriverRead;
        data["isRated"] = this.isRated;
        data["rate"] = this.rate;
        data["isAccepted"] = this.isAccepted;
        data["offerStatus"] = this.offerStatus;
        data["driverName"] = this.driverName;
        data["clientName"] = this.clientName;
        data["deliveryCost"] = this.deliveryCost;
        data["vat"] = this.vat;
        data["awayFrom"] = this.awayFrom;
        data["deliveryThroughDays"] = this.deliveryThroughDays;
        data["deliveryThroughHours"] = this.deliveryThroughHours;
        data["deliveryThroughMinutes"] = this.deliveryThroughMinutes;
        data["deliveryThroughSeconds"] = this.deliveryThroughSeconds;
        data["requestId"] = this.requestId;
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["driverId"] = this.driverId;
        data["driver"] = this.driver ? this.driver.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): OfferPrice {
        const json = this.toJSON();
        let result = new OfferPrice();
        result.init(json);
        return result;
    }
}

export interface IOfferPrice {
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    isRead: boolean | undefined;
    isDriverRead: boolean | undefined;
    isRated: boolean | undefined;
    rate: number | undefined;
    isAccepted: boolean | undefined;
    offerStatus: number;
    driverName: string | undefined;
    clientName: string | undefined;
    deliveryCost: number;
    vat: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    request: Request;
    driverId: number;
    driver: User;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Request implements IRequest {
    isReg: boolean | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    isRated: boolean | undefined;
    rate: number | undefined;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    subcategory: Subcategory;
    userRequsetId: number;
    userRequset: User;
    status: number;
    deliveryCost: string | undefined;
    receiverMobile: string | undefined;
    offerPrices: OfferPrice[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isReg = _data["isReg"];
            this.isClientRated = _data["isClientRated"];
            this.clientRate = _data["clientRate"];
            this.isRated = _data["isRated"];
            this.rate = _data["rate"];
            this.discountPercentage = _data["discountPercentage"];
            this.arrivalDateTime = _data["arrivalDateTime"] ? moment(_data["arrivalDateTime"].toString()) : <any>undefined;
            this.paymentWay = _data["paymentWay"];
            this.notes = _data["notes"];
            this.startingPoint = _data["startingPoint"];
            this.endingPoint = _data["endingPoint"];
            this.stratingPointAdress = _data["stratingPointAdress"];
            this.stratingPointTitle = _data["stratingPointTitle"];
            this.endingPointAdress = _data["endingPointAdress"];
            this.endingPointTitle = _data["endingPointTitle"];
            this.subcategoryId = _data["subcategoryId"];
            this.subcategory = _data["subcategory"] ? Subcategory.fromJS(_data["subcategory"]) : <any>undefined;
            this.userRequsetId = _data["userRequsetId"];
            this.userRequset = _data["userRequset"] ? User.fromJS(_data["userRequset"]) : <any>undefined;
            this.status = _data["status"];
            this.deliveryCost = _data["deliveryCost"];
            this.receiverMobile = _data["receiverMobile"];
            if (Array.isArray(_data["offerPrices"])) {
                this.offerPrices = [] as any;
                for (let item of _data["offerPrices"])
                    this.offerPrices.push(OfferPrice.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isReg"] = this.isReg;
        data["isClientRated"] = this.isClientRated;
        data["clientRate"] = this.clientRate;
        data["isRated"] = this.isRated;
        data["rate"] = this.rate;
        data["discountPercentage"] = this.discountPercentage;
        data["arrivalDateTime"] = this.arrivalDateTime ? this.arrivalDateTime.toISOString() : <any>undefined;
        data["paymentWay"] = this.paymentWay;
        data["notes"] = this.notes;
        data["startingPoint"] = this.startingPoint;
        data["endingPoint"] = this.endingPoint;
        data["stratingPointAdress"] = this.stratingPointAdress;
        data["stratingPointTitle"] = this.stratingPointTitle;
        data["endingPointAdress"] = this.endingPointAdress;
        data["endingPointTitle"] = this.endingPointTitle;
        data["subcategoryId"] = this.subcategoryId;
        data["subcategory"] = this.subcategory ? this.subcategory.toJSON() : <any>undefined;
        data["userRequsetId"] = this.userRequsetId;
        data["userRequset"] = this.userRequset ? this.userRequset.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["deliveryCost"] = this.deliveryCost;
        data["receiverMobile"] = this.receiverMobile;
        if (Array.isArray(this.offerPrices)) {
            data["offerPrices"] = [];
            for (let item of this.offerPrices)
                data["offerPrices"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Request {
        const json = this.toJSON();
        let result = new Request();
        result.init(json);
        return result;
    }
}

export interface IRequest {
    isReg: boolean | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    isRated: boolean | undefined;
    rate: number | undefined;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    subcategory: Subcategory;
    userRequsetId: number;
    userRequset: User;
    status: number;
    deliveryCost: string | undefined;
    receiverMobile: string | undefined;
    offerPrices: OfferPrice[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Subcategory implements ISubcategory {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    categoryId: number;
    category: Category;
    requests: Request[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ISubcategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionFa = _data["descriptionFa"];
            this.image = _data["image"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            if (Array.isArray(_data["requests"])) {
                this.requests = [] as any;
                for (let item of _data["requests"])
                    this.requests.push(Request.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Subcategory {
        data = typeof data === 'object' ? data : {};
        let result = new Subcategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionFa"] = this.descriptionFa;
        data["image"] = this.image;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.requests)) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Subcategory {
        const json = this.toJSON();
        let result = new Subcategory();
        result.init(json);
        return result;
    }
}

export interface ISubcategory {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    categoryId: number;
    category: Category;
    requests: Request[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Category implements ICategory {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    image: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    subcategories: Subcategory[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.image = _data["image"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionFa = _data["descriptionFa"];
            if (Array.isArray(_data["subcategories"])) {
                this.subcategories = [] as any;
                for (let item of _data["subcategories"])
                    this.subcategories.push(Subcategory.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["image"] = this.image;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionFa"] = this.descriptionFa;
        if (Array.isArray(this.subcategories)) {
            data["subcategories"] = [];
            for (let item of this.subcategories)
                data["subcategories"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Category {
        const json = this.toJSON();
        let result = new Category();
        result.init(json);
        return result;
    }
}

export interface ICategory {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    image: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    subcategories: Subcategory[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class CategoryDto implements ICategoryDto {
    displayName: string | undefined;
    displayDescription: string | undefined;
    image: string | undefined;
    id: number;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.displayDescription = _data["displayDescription"];
            this.image = _data["image"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["displayDescription"] = this.displayDescription;
        data["image"] = this.image;
        data["id"] = this.id;
        return data; 
    }

    clone(): CategoryDto {
        const json = this.toJSON();
        let result = new CategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryDto {
    displayName: string | undefined;
    displayDescription: string | undefined;
    image: string | undefined;
    id: number;
}

export class CategoryDtoPagedResultDto implements ICategoryDtoPagedResultDto {
    totalCount: number;
    items: CategoryDto[] | undefined;

    constructor(data?: ICategoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CategoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CategoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryDtoPagedResultDto {
    totalCount: number;
    items: CategoryDto[] | undefined;
}

export class CreateCategoryDto implements ICreateCategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;

    constructor(data?: ICreateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionFa = _data["descriptionFa"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): CreateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionFa"] = this.descriptionFa;
        data["image"] = this.image;
        return data; 
    }

    clone(): CreateCategoryDto {
        const json = this.toJSON();
        let result = new CreateCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
}

export class UpdateCategoryDto implements IUpdateCategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    id: number;

    constructor(data?: IUpdateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionFa = _data["descriptionFa"];
            this.image = _data["image"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionFa"] = this.descriptionFa;
        data["image"] = this.image;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateCategoryDto {
        const json = this.toJSON();
        let result = new UpdateCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    id: number;
}

export class CreateClientDto implements ICreateClientDto {
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    companyId: number | undefined;

    constructor(data?: ICreateClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.picture = _data["picture"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): CreateClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["picture"] = this.picture;
        data["companyId"] = this.companyId;
        return data; 
    }

    clone(): CreateClientDto {
        const json = this.toJSON();
        let result = new CreateClientDto();
        result.init(json);
        return result;
    }
}

export interface ICreateClientDto {
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    companyId: number | undefined;
}

export class UpdateClientDto implements IUpdateClientDto {
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    companyId: number | undefined;
    id: number;

    constructor(data?: IUpdateClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.picture = _data["picture"];
            this.companyId = _data["companyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["picture"] = this.picture;
        data["companyId"] = this.companyId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateClientDto {
        const json = this.toJSON();
        let result = new UpdateClientDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateClientDto {
    email: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    picture: string | undefined;
    companyId: number | undefined;
    id: number;
}

export class ClientDtoPagedResultDto implements IClientDtoPagedResultDto {
    totalCount: number;
    items: ClientDto[] | undefined;

    constructor(data?: IClientDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ClientDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ClientDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ClientDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IClientDtoPagedResultDto {
    totalCount: number;
    items: ClientDto[] | undefined;
}

export class ClientAdressDto implements IClientAdressDto {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;
    id: number;

    constructor(data?: IClientAdressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adress = _data["adress"];
            this.title = _data["title"];
            this.langLat = _data["langLat"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClientAdressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAdressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adress"] = this.adress;
        data["title"] = this.title;
        data["langLat"] = this.langLat;
        data["id"] = this.id;
        return data; 
    }

    clone(): ClientAdressDto {
        const json = this.toJSON();
        let result = new ClientAdressDto();
        result.init(json);
        return result;
    }
}

export interface IClientAdressDto {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;
    id: number;
}

export class UpdateClientAdressDto implements IUpdateClientAdressDto {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;
    id: number;

    constructor(data?: IUpdateClientAdressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adress = _data["adress"];
            this.title = _data["title"];
            this.langLat = _data["langLat"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateClientAdressDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientAdressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adress"] = this.adress;
        data["title"] = this.title;
        data["langLat"] = this.langLat;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateClientAdressDto {
        const json = this.toJSON();
        let result = new UpdateClientAdressDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateClientAdressDto {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;
    id: number;
}

export class ClientAdressDtoPagedResultDto implements IClientAdressDtoPagedResultDto {
    totalCount: number;
    items: ClientAdressDto[] | undefined;

    constructor(data?: IClientAdressDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ClientAdressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientAdressDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAdressDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ClientAdressDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ClientAdressDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IClientAdressDtoPagedResultDto {
    totalCount: number;
    items: ClientAdressDto[] | undefined;
}

export class CreateClientAdressDto implements ICreateClientAdressDto {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;

    constructor(data?: ICreateClientAdressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adress = _data["adress"];
            this.title = _data["title"];
            this.langLat = _data["langLat"];
        }
    }

    static fromJS(data: any): CreateClientAdressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientAdressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adress"] = this.adress;
        data["title"] = this.title;
        data["langLat"] = this.langLat;
        return data; 
    }

    clone(): CreateClientAdressDto {
        const json = this.toJSON();
        let result = new CreateClientAdressDto();
        result.init(json);
        return result;
    }
}

export interface ICreateClientAdressDto {
    adress: string | undefined;
    title: string | undefined;
    langLat: string | undefined;
}

export class TermsAndPolicyDto implements ITermsAndPolicyDto {
    contentText: string | undefined;

    constructor(data?: ITermsAndPolicyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentText = _data["contentText"];
        }
    }

    static fromJS(data: any): TermsAndPolicyDto {
        data = typeof data === 'object' ? data : {};
        let result = new TermsAndPolicyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentText"] = this.contentText;
        return data; 
    }

    clone(): TermsAndPolicyDto {
        const json = this.toJSON();
        let result = new TermsAndPolicyDto();
        result.init(json);
        return result;
    }
}

export interface ITermsAndPolicyDto {
    contentText: string | undefined;
}

export class CreateTermsAndPolicyDto implements ICreateTermsAndPolicyDto {
    content: string | undefined;
    contentAr: string | undefined;

    constructor(data?: ICreateTermsAndPolicyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.contentAr = _data["contentAr"];
        }
    }

    static fromJS(data: any): CreateTermsAndPolicyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTermsAndPolicyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["contentAr"] = this.contentAr;
        return data; 
    }

    clone(): CreateTermsAndPolicyDto {
        const json = this.toJSON();
        let result = new CreateTermsAndPolicyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTermsAndPolicyDto {
    content: string | undefined;
    contentAr: string | undefined;
}

export class AboutDto implements IAboutDto {
    contentText: string | undefined;

    constructor(data?: IAboutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentText = _data["contentText"];
        }
    }

    static fromJS(data: any): AboutDto {
        data = typeof data === 'object' ? data : {};
        let result = new AboutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentText"] = this.contentText;
        return data; 
    }

    clone(): AboutDto {
        const json = this.toJSON();
        let result = new AboutDto();
        result.init(json);
        return result;
    }
}

export interface IAboutDto {
    contentText: string | undefined;
}

export class CreateAboutDto implements ICreateAboutDto {
    content: string | undefined;
    contentAr: string | undefined;

    constructor(data?: ICreateAboutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.contentAr = _data["contentAr"];
        }
    }

    static fromJS(data: any): CreateAboutDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAboutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["contentAr"] = this.contentAr;
        return data; 
    }

    clone(): CreateAboutDto {
        const json = this.toJSON();
        let result = new CreateAboutDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAboutDto {
    content: string | undefined;
    contentAr: string | undefined;
}

export class CompanyDto implements ICompanyDto {
    name: string | undefined;
    nameAr: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    displayName: string | undefined;
    displayDescription: string | undefined;
    id: number;

    constructor(data?: ICompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.displayName = _data["displayName"];
            this.displayDescription = _data["displayDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["displayName"] = this.displayName;
        data["displayDescription"] = this.displayDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): CompanyDto {
        const json = this.toJSON();
        let result = new CompanyDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyDto {
    name: string | undefined;
    nameAr: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    displayName: string | undefined;
    displayDescription: string | undefined;
    id: number;
}

export class CompanyDtoPagedResultDto implements ICompanyDtoPagedResultDto {
    totalCount: number;
    items: CompanyDto[] | undefined;

    constructor(data?: ICompanyDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CompanyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanyDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CompanyDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CompanyDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyDtoPagedResultDto {
    totalCount: number;
    items: CompanyDto[] | undefined;
}

export class CreateCompanyDto implements ICreateCompanyDto {
    name: string | undefined;
    nameAr: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;

    constructor(data?: ICreateCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
        }
    }

    static fromJS(data: any): CreateCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        return data; 
    }

    clone(): CreateCompanyDto {
        const json = this.toJSON();
        let result = new CreateCompanyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCompanyDto {
    name: string | undefined;
    nameAr: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
}

export class UpdateCompanyDto implements IUpdateCompanyDto {
    name: string | undefined;
    nameAr: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    id: number;

    constructor(data?: IUpdateCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateCompanyDto {
        const json = this.toJSON();
        let result = new UpdateCompanyDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCompanyDto {
    name: string | undefined;
    nameAr: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    id: number;
}

export class CompanyDriversReuestDto implements ICompanyDriversReuestDto {
    categoryDisplayName: string | undefined;
    isReg: boolean | undefined;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    subcategoryDisplayName: string | undefined;
    status: number;
    requestStateName: string | undefined;
    deliveryCost: string | undefined;
    isRated: boolean | undefined;
    rate: number | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    creationTime: moment.Moment;
    ctString: string | undefined;
    acceptedDriverName: string | undefined;
    net: number;
    customerName: string | undefined;
    vat: number;
    vatAmount: number;
    client: ShortClientDto;
    id: number;

    constructor(data?: ICompanyDriversReuestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryDisplayName = _data["categoryDisplayName"];
            this.isReg = _data["isReg"];
            this.discountPercentage = _data["discountPercentage"];
            this.arrivalDateTime = _data["arrivalDateTime"] ? moment(_data["arrivalDateTime"].toString()) : <any>undefined;
            this.paymentWay = _data["paymentWay"];
            this.notes = _data["notes"];
            this.startingPoint = _data["startingPoint"];
            this.endingPoint = _data["endingPoint"];
            this.stratingPointAdress = _data["stratingPointAdress"];
            this.stratingPointTitle = _data["stratingPointTitle"];
            this.endingPointAdress = _data["endingPointAdress"];
            this.endingPointTitle = _data["endingPointTitle"];
            this.subcategoryId = _data["subcategoryId"];
            this.subcategoryDisplayName = _data["subcategoryDisplayName"];
            this.status = _data["status"];
            this.requestStateName = _data["requestStateName"];
            this.deliveryCost = _data["deliveryCost"];
            this.isRated = _data["isRated"];
            this.rate = _data["rate"];
            this.isClientRated = _data["isClientRated"];
            this.clientRate = _data["clientRate"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.ctString = _data["ctString"];
            this.acceptedDriverName = _data["acceptedDriverName"];
            this.net = _data["net"];
            this.customerName = _data["customerName"];
            this.vat = _data["vat"];
            this.vatAmount = _data["vatAmount"];
            this.client = _data["client"] ? ShortClientDto.fromJS(_data["client"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompanyDriversReuestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDriversReuestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryDisplayName"] = this.categoryDisplayName;
        data["isReg"] = this.isReg;
        data["discountPercentage"] = this.discountPercentage;
        data["arrivalDateTime"] = this.arrivalDateTime ? this.arrivalDateTime.toISOString() : <any>undefined;
        data["paymentWay"] = this.paymentWay;
        data["notes"] = this.notes;
        data["startingPoint"] = this.startingPoint;
        data["endingPoint"] = this.endingPoint;
        data["stratingPointAdress"] = this.stratingPointAdress;
        data["stratingPointTitle"] = this.stratingPointTitle;
        data["endingPointAdress"] = this.endingPointAdress;
        data["endingPointTitle"] = this.endingPointTitle;
        data["subcategoryId"] = this.subcategoryId;
        data["subcategoryDisplayName"] = this.subcategoryDisplayName;
        data["status"] = this.status;
        data["requestStateName"] = this.requestStateName;
        data["deliveryCost"] = this.deliveryCost;
        data["isRated"] = this.isRated;
        data["rate"] = this.rate;
        data["isClientRated"] = this.isClientRated;
        data["clientRate"] = this.clientRate;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["ctString"] = this.ctString;
        data["acceptedDriverName"] = this.acceptedDriverName;
        data["net"] = this.net;
        data["customerName"] = this.customerName;
        data["vat"] = this.vat;
        data["vatAmount"] = this.vatAmount;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CompanyDriversReuestDto {
        const json = this.toJSON();
        let result = new CompanyDriversReuestDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyDriversReuestDto {
    categoryDisplayName: string | undefined;
    isReg: boolean | undefined;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    subcategoryDisplayName: string | undefined;
    status: number;
    requestStateName: string | undefined;
    deliveryCost: string | undefined;
    isRated: boolean | undefined;
    rate: number | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    creationTime: moment.Moment;
    ctString: string | undefined;
    acceptedDriverName: string | undefined;
    net: number;
    customerName: string | undefined;
    vat: number;
    vatAmount: number;
    client: ShortClientDto;
    id: number;
}

export class CompanyDriversReuestDtoPagedResultDto implements ICompanyDriversReuestDtoPagedResultDto {
    totalCount: number;
    items: CompanyDriversReuestDto[] | undefined;

    constructor(data?: ICompanyDriversReuestDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CompanyDriversReuestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanyDriversReuestDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDriversReuestDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CompanyDriversReuestDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CompanyDriversReuestDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyDriversReuestDtoPagedResultDto {
    totalCount: number;
    items: CompanyDriversReuestDto[] | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string | undefined;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string | undefined;
}

export class ValidateCouponInput implements IValidateCouponInput {
    couponCode: string | undefined;
    clientId: number;

    constructor(data?: IValidateCouponInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.couponCode = _data["couponCode"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ValidateCouponInput {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateCouponInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["couponCode"] = this.couponCode;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ValidateCouponInput {
        const json = this.toJSON();
        let result = new ValidateCouponInput();
        result.init(json);
        return result;
    }
}

export interface IValidateCouponInput {
    couponCode: string | undefined;
    clientId: number;
}

export class CouponDto implements ICouponDto {
    code: string | undefined;
    couponType: CouponTypes;
    value: number;
    active: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: ICouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.couponType = _data["couponType"];
            this.value = _data["value"];
            this.active = _data["active"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["couponType"] = this.couponType;
        data["value"] = this.value;
        data["active"] = this.active;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CouponDto {
        const json = this.toJSON();
        let result = new CouponDto();
        result.init(json);
        return result;
    }
}

export interface ICouponDto {
    code: string | undefined;
    couponType: CouponTypes;
    value: number;
    active: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class CouponDtoPagedResultDto implements ICouponDtoPagedResultDto {
    totalCount: number;
    items: CouponDto[] | undefined;

    constructor(data?: ICouponDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CouponDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CouponDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CouponDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CouponDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICouponDtoPagedResultDto {
    totalCount: number;
    items: CouponDto[] | undefined;
}

export class CreateCouponDto implements ICreateCouponDto {
    code: string | undefined;
    couponType: CouponTypes;
    value: number;
    active: boolean;

    constructor(data?: ICreateCouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.couponType = _data["couponType"];
            this.value = _data["value"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): CreateCouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["couponType"] = this.couponType;
        data["value"] = this.value;
        data["active"] = this.active;
        return data; 
    }

    clone(): CreateCouponDto {
        const json = this.toJSON();
        let result = new CreateCouponDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCouponDto {
    code: string | undefined;
    couponType: CouponTypes;
    value: number;
    active: boolean;
}

export class UpdateCouponDto implements IUpdateCouponDto {
    code: string | undefined;
    couponType: CouponTypes;
    value: number;
    active: boolean;
    id: number;

    constructor(data?: IUpdateCouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.couponType = _data["couponType"];
            this.value = _data["value"];
            this.active = _data["active"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["couponType"] = this.couponType;
        data["value"] = this.value;
        data["active"] = this.active;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateCouponDto {
        const json = this.toJSON();
        let result = new UpdateCouponDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCouponDto {
    code: string | undefined;
    couponType: CouponTypes;
    value: number;
    active: boolean;
    id: number;
}

export class CreateDriverDto implements ICreateDriverDto {
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    offDuty: boolean;
    isDriverAvilable: boolean;
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    phone: string | undefined;
    companyId: number | undefined;
    isWaselDriver: boolean;
    isWaselVehicle: boolean;
    plateTypeId: number | undefined;

    constructor(data?: ICreateDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.vehicleType = _data["vehicleType"];
            this.dateOfBirthGregorian = _data["dateOfBirthGregorian"] ? moment(_data["dateOfBirthGregorian"].toString()) : <any>undefined;
            this.dateOfBirthHijri = _data["dateOfBirthHijri"];
            this.mobileNumber = _data["mobileNumber"];
            this.addressTitle = _data["addressTitle"];
            this.lat = _data["lat"];
            this.long = _data["long"];
            this.plate = _data["plate"];
            this.offDuty = _data["offDuty"];
            this.isDriverAvilable = _data["isDriverAvilable"];
            this.vehicleSequenceNumber = _data["vehicleSequenceNumber"];
            this.driverIdentityNumber = _data["driverIdentityNumber"];
            this.phone = _data["phone"];
            this.companyId = _data["companyId"];
            this.isWaselDriver = _data["isWaselDriver"];
            this.isWaselVehicle = _data["isWaselVehicle"];
            this.plateTypeId = _data["plateTypeId"];
        }
    }

    static fromJS(data: any): CreateDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["vehicleType"] = this.vehicleType;
        data["dateOfBirthGregorian"] = this.dateOfBirthGregorian ? this.dateOfBirthGregorian.toISOString() : <any>undefined;
        data["dateOfBirthHijri"] = this.dateOfBirthHijri;
        data["mobileNumber"] = this.mobileNumber;
        data["addressTitle"] = this.addressTitle;
        data["lat"] = this.lat;
        data["long"] = this.long;
        data["plate"] = this.plate;
        data["offDuty"] = this.offDuty;
        data["isDriverAvilable"] = this.isDriverAvilable;
        data["vehicleSequenceNumber"] = this.vehicleSequenceNumber;
        data["driverIdentityNumber"] = this.driverIdentityNumber;
        data["phone"] = this.phone;
        data["companyId"] = this.companyId;
        data["isWaselDriver"] = this.isWaselDriver;
        data["isWaselVehicle"] = this.isWaselVehicle;
        data["plateTypeId"] = this.plateTypeId;
        return data; 
    }

    clone(): CreateDriverDto {
        const json = this.toJSON();
        let result = new CreateDriverDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDriverDto {
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    offDuty: boolean;
    isDriverAvilable: boolean;
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    phone: string | undefined;
    companyId: number | undefined;
    isWaselDriver: boolean;
    isWaselVehicle: boolean;
    plateTypeId: number | undefined;
}

export class UpdateDriverDto implements IUpdateDriverDto {
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    offDuty: boolean;
    isDriverAvilable: boolean;
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    phone: string | undefined;
    companyId: number | undefined;
    isWaselDriver: boolean;
    isWaselVehicle: boolean;
    plateTypeId: number | undefined;
    id: number;

    constructor(data?: IUpdateDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.vehicleType = _data["vehicleType"];
            this.dateOfBirthGregorian = _data["dateOfBirthGregorian"] ? moment(_data["dateOfBirthGregorian"].toString()) : <any>undefined;
            this.dateOfBirthHijri = _data["dateOfBirthHijri"];
            this.mobileNumber = _data["mobileNumber"];
            this.addressTitle = _data["addressTitle"];
            this.lat = _data["lat"];
            this.long = _data["long"];
            this.plate = _data["plate"];
            this.offDuty = _data["offDuty"];
            this.isDriverAvilable = _data["isDriverAvilable"];
            this.vehicleSequenceNumber = _data["vehicleSequenceNumber"];
            this.driverIdentityNumber = _data["driverIdentityNumber"];
            this.phone = _data["phone"];
            this.companyId = _data["companyId"];
            this.isWaselDriver = _data["isWaselDriver"];
            this.isWaselVehicle = _data["isWaselVehicle"];
            this.plateTypeId = _data["plateTypeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["vehicleType"] = this.vehicleType;
        data["dateOfBirthGregorian"] = this.dateOfBirthGregorian ? this.dateOfBirthGregorian.toISOString() : <any>undefined;
        data["dateOfBirthHijri"] = this.dateOfBirthHijri;
        data["mobileNumber"] = this.mobileNumber;
        data["addressTitle"] = this.addressTitle;
        data["lat"] = this.lat;
        data["long"] = this.long;
        data["plate"] = this.plate;
        data["offDuty"] = this.offDuty;
        data["isDriverAvilable"] = this.isDriverAvilable;
        data["vehicleSequenceNumber"] = this.vehicleSequenceNumber;
        data["driverIdentityNumber"] = this.driverIdentityNumber;
        data["phone"] = this.phone;
        data["companyId"] = this.companyId;
        data["isWaselDriver"] = this.isWaselDriver;
        data["isWaselVehicle"] = this.isWaselVehicle;
        data["plateTypeId"] = this.plateTypeId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateDriverDto {
        const json = this.toJSON();
        let result = new UpdateDriverDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateDriverDto {
    email: string | undefined;
    fullName: string | undefined;
    vehicleType: number;
    dateOfBirthGregorian: moment.Moment | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    addressTitle: string | undefined;
    lat: number;
    long: number;
    plate: string | undefined;
    offDuty: boolean;
    isDriverAvilable: boolean;
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    phone: string | undefined;
    companyId: number | undefined;
    isWaselDriver: boolean;
    isWaselVehicle: boolean;
    plateTypeId: number | undefined;
    id: number;
}

export class UpdateDriverLocationInput implements IUpdateDriverLocationInput {
    driverId: number;
    lat: number;
    long: number;

    constructor(data?: IUpdateDriverLocationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.driverId = _data["driverId"];
            this.lat = _data["lat"];
            this.long = _data["long"];
        }
    }

    static fromJS(data: any): UpdateDriverLocationInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDriverLocationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["driverId"] = this.driverId;
        data["lat"] = this.lat;
        data["long"] = this.long;
        return data; 
    }

    clone(): UpdateDriverLocationInput {
        const json = this.toJSON();
        let result = new UpdateDriverLocationInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateDriverLocationInput {
    driverId: number;
    lat: number;
    long: number;
}

export class GeNearestDriversInput implements IGeNearestDriversInput {
    latitude: number;
    longitude: number;
    subCategoryId: number | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IGeNearestDriversInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.subCategoryId = _data["subCategoryId"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): GeNearestDriversInput {
        data = typeof data === 'object' ? data : {};
        let result = new GeNearestDriversInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["subCategoryId"] = this.subCategoryId;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): GeNearestDriversInput {
        const json = this.toJSON();
        let result = new GeNearestDriversInput();
        result.init(json);
        return result;
    }
}

export interface IGeNearestDriversInput {
    latitude: number;
    longitude: number;
    subCategoryId: number | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class DriverDtoPagedResultDto implements IDriverDtoPagedResultDto {
    totalCount: number;
    items: DriverDto[] | undefined;

    constructor(data?: IDriverDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DriverDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DriverDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DriverDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DriverDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DriverDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDriverDtoPagedResultDto {
    totalCount: number;
    items: DriverDto[] | undefined;
}

export class DriverJoinRequestDto implements IDriverJoinRequestDto {
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    mobilePhone: string | undefined;
    companyName: string | undefined;
    id: number;

    constructor(data?: IDriverJoinRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.mobilePhone = _data["mobilePhone"];
            this.companyName = _data["companyName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DriverJoinRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new DriverJoinRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["mobilePhone"] = this.mobilePhone;
        data["companyName"] = this.companyName;
        data["id"] = this.id;
        return data; 
    }

    clone(): DriverJoinRequestDto {
        const json = this.toJSON();
        let result = new DriverJoinRequestDto();
        result.init(json);
        return result;
    }
}

export interface IDriverJoinRequestDto {
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    mobilePhone: string | undefined;
    companyName: string | undefined;
    id: number;
}

export class DriverJoinRequestDtoPagedResultDto implements IDriverJoinRequestDtoPagedResultDto {
    totalCount: number;
    items: DriverJoinRequestDto[] | undefined;

    constructor(data?: IDriverJoinRequestDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DriverJoinRequestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DriverJoinRequestDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DriverJoinRequestDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DriverJoinRequestDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DriverJoinRequestDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDriverJoinRequestDtoPagedResultDto {
    totalCount: number;
    items: DriverJoinRequestDto[] | undefined;
}

export class AdminCreateDriverJoinRequestDto implements IAdminCreateDriverJoinRequestDto {
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    mobilePhone: string | undefined;
    companyName: string | undefined;

    constructor(data?: IAdminCreateDriverJoinRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.mobilePhone = _data["mobilePhone"];
            this.companyName = _data["companyName"];
        }
    }

    static fromJS(data: any): AdminCreateDriverJoinRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreateDriverJoinRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["mobilePhone"] = this.mobilePhone;
        data["companyName"] = this.companyName;
        return data; 
    }

    clone(): AdminCreateDriverJoinRequestDto {
        const json = this.toJSON();
        let result = new AdminCreateDriverJoinRequestDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCreateDriverJoinRequestDto {
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    mobilePhone: string | undefined;
    companyName: string | undefined;
}

export class AdminUpdateDriverJoinRequestDto implements IAdminUpdateDriverJoinRequestDto {
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    mobilePhone: string | undefined;
    companyName: string | undefined;
    id: number;

    constructor(data?: IAdminUpdateDriverJoinRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.mobilePhone = _data["mobilePhone"];
            this.companyName = _data["companyName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminUpdateDriverJoinRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminUpdateDriverJoinRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["mobilePhone"] = this.mobilePhone;
        data["companyName"] = this.companyName;
        data["id"] = this.id;
        return data; 
    }

    clone(): AdminUpdateDriverJoinRequestDto {
        const json = this.toJSON();
        let result = new AdminUpdateDriverJoinRequestDto();
        result.init(json);
        return result;
    }
}

export interface IAdminUpdateDriverJoinRequestDto {
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    mobilePhone: string | undefined;
    companyName: string | undefined;
    id: number;
}

export class SetUserFireTokenDto implements ISetUserFireTokenDto {
    token: string | undefined;

    constructor(data?: ISetUserFireTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): SetUserFireTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetUserFireTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data; 
    }

    clone(): SetUserFireTokenDto {
        const json = this.toJSON();
        let result = new SetUserFireTokenDto();
        result.init(json);
        return result;
    }
}

export interface ISetUserFireTokenDto {
    token: string | undefined;
}

export class UserFireTokenDto implements IUserFireTokenDto {
    token: string | undefined;

    constructor(data?: IUserFireTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): UserFireTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserFireTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data; 
    }

    clone(): UserFireTokenDto {
        const json = this.toJSON();
        let result = new UserFireTokenDto();
        result.init(json);
        return result;
    }
}

export interface IUserFireTokenDto {
    token: string | undefined;
}

export class SendClientNotificationDto implements ISendClientNotificationDto {
    clientIds: number[] | undefined;
    title: string | undefined;
    message: string | undefined;

    constructor(data?: ISendClientNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clientIds"])) {
                this.clientIds = [] as any;
                for (let item of _data["clientIds"])
                    this.clientIds.push(item);
            }
            this.title = _data["title"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SendClientNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendClientNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clientIds)) {
            data["clientIds"] = [];
            for (let item of this.clientIds)
                data["clientIds"].push(item);
        }
        data["title"] = this.title;
        data["message"] = this.message;
        return data; 
    }

    clone(): SendClientNotificationDto {
        const json = this.toJSON();
        let result = new SendClientNotificationDto();
        result.init(json);
        return result;
    }
}

export interface ISendClientNotificationDto {
    clientIds: number[] | undefined;
    title: string | undefined;
    message: string | undefined;
}

export class RequestWOfferPriceDto implements IRequestWOfferPriceDto {
    offerPriceId: number;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    status: number;
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    driverId: number;
    driverName: string | undefined;
    offerStatus: number;
    isRated: boolean | undefined;
    rate: number | undefined;
    isRead: boolean | undefined;
    isDriverRead: boolean | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    clientName: string | undefined;
    readonly driverAvrgRate: number;

    constructor(data?: IRequestWOfferPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offerPriceId = _data["offerPriceId"];
            this.discountPercentage = _data["discountPercentage"];
            this.arrivalDateTime = _data["arrivalDateTime"] ? moment(_data["arrivalDateTime"].toString()) : <any>undefined;
            this.paymentWay = _data["paymentWay"];
            this.notes = _data["notes"];
            this.startingPoint = _data["startingPoint"];
            this.endingPoint = _data["endingPoint"];
            this.stratingPointAdress = _data["stratingPointAdress"];
            this.stratingPointTitle = _data["stratingPointTitle"];
            this.endingPointAdress = _data["endingPointAdress"];
            this.endingPointTitle = _data["endingPointTitle"];
            this.subcategoryId = _data["subcategoryId"];
            this.status = _data["status"];
            this.deliveryCost = _data["deliveryCost"];
            this.awayFrom = _data["awayFrom"];
            this.deliveryThroughDays = _data["deliveryThroughDays"];
            this.deliveryThroughHours = _data["deliveryThroughHours"];
            this.deliveryThroughMinutes = _data["deliveryThroughMinutes"];
            this.deliveryThroughSeconds = _data["deliveryThroughSeconds"];
            this.requestId = _data["requestId"];
            this.driverId = _data["driverId"];
            this.driverName = _data["driverName"];
            this.offerStatus = _data["offerStatus"];
            this.isRated = _data["isRated"];
            this.rate = _data["rate"];
            this.isRead = _data["isRead"];
            this.isDriverRead = _data["isDriverRead"];
            this.isClientRated = _data["isClientRated"];
            this.clientRate = _data["clientRate"];
            this.clientName = _data["clientName"];
            (<any>this).driverAvrgRate = _data["driverAvrgRate"];
        }
    }

    static fromJS(data: any): RequestWOfferPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestWOfferPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offerPriceId"] = this.offerPriceId;
        data["discountPercentage"] = this.discountPercentage;
        data["arrivalDateTime"] = this.arrivalDateTime ? this.arrivalDateTime.toISOString() : <any>undefined;
        data["paymentWay"] = this.paymentWay;
        data["notes"] = this.notes;
        data["startingPoint"] = this.startingPoint;
        data["endingPoint"] = this.endingPoint;
        data["stratingPointAdress"] = this.stratingPointAdress;
        data["stratingPointTitle"] = this.stratingPointTitle;
        data["endingPointAdress"] = this.endingPointAdress;
        data["endingPointTitle"] = this.endingPointTitle;
        data["subcategoryId"] = this.subcategoryId;
        data["status"] = this.status;
        data["deliveryCost"] = this.deliveryCost;
        data["awayFrom"] = this.awayFrom;
        data["deliveryThroughDays"] = this.deliveryThroughDays;
        data["deliveryThroughHours"] = this.deliveryThroughHours;
        data["deliveryThroughMinutes"] = this.deliveryThroughMinutes;
        data["deliveryThroughSeconds"] = this.deliveryThroughSeconds;
        data["requestId"] = this.requestId;
        data["driverId"] = this.driverId;
        data["driverName"] = this.driverName;
        data["offerStatus"] = this.offerStatus;
        data["isRated"] = this.isRated;
        data["rate"] = this.rate;
        data["isRead"] = this.isRead;
        data["isDriverRead"] = this.isDriverRead;
        data["isClientRated"] = this.isClientRated;
        data["clientRate"] = this.clientRate;
        data["clientName"] = this.clientName;
        data["driverAvrgRate"] = this.driverAvrgRate;
        return data; 
    }

    clone(): RequestWOfferPriceDto {
        const json = this.toJSON();
        let result = new RequestWOfferPriceDto();
        result.init(json);
        return result;
    }
}

export interface IRequestWOfferPriceDto {
    offerPriceId: number;
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    status: number;
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    driverId: number;
    driverName: string | undefined;
    offerStatus: number;
    isRated: boolean | undefined;
    rate: number | undefined;
    isRead: boolean | undefined;
    isDriverRead: boolean | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    clientName: string | undefined;
    driverAvrgRate: number;
}

export class RequestWOfferPriceDtoPagedResultDto implements IRequestWOfferPriceDtoPagedResultDto {
    totalCount: number;
    items: RequestWOfferPriceDto[] | undefined;

    constructor(data?: IRequestWOfferPriceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RequestWOfferPriceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestWOfferPriceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestWOfferPriceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RequestWOfferPriceDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RequestWOfferPriceDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRequestWOfferPriceDtoPagedResultDto {
    totalCount: number;
    items: RequestWOfferPriceDto[] | undefined;
}

export class CreateOfferPriceDto implements ICreateOfferPriceDto {
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    driverUserId: number;

    constructor(data?: ICreateOfferPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deliveryCost = _data["deliveryCost"];
            this.awayFrom = _data["awayFrom"];
            this.deliveryThroughDays = _data["deliveryThroughDays"];
            this.deliveryThroughHours = _data["deliveryThroughHours"];
            this.deliveryThroughMinutes = _data["deliveryThroughMinutes"];
            this.deliveryThroughSeconds = _data["deliveryThroughSeconds"];
            this.requestId = _data["requestId"];
            this.driverUserId = _data["driverUserId"];
        }
    }

    static fromJS(data: any): CreateOfferPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOfferPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryCost"] = this.deliveryCost;
        data["awayFrom"] = this.awayFrom;
        data["deliveryThroughDays"] = this.deliveryThroughDays;
        data["deliveryThroughHours"] = this.deliveryThroughHours;
        data["deliveryThroughMinutes"] = this.deliveryThroughMinutes;
        data["deliveryThroughSeconds"] = this.deliveryThroughSeconds;
        data["requestId"] = this.requestId;
        data["driverUserId"] = this.driverUserId;
        return data; 
    }

    clone(): CreateOfferPriceDto {
        const json = this.toJSON();
        let result = new CreateOfferPriceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOfferPriceDto {
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    driverUserId: number;
}

export class RateDriverByOfferDto implements IRateDriverByOfferDto {
    offerPriceId: number;
    rate: number;

    constructor(data?: IRateDriverByOfferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offerPriceId = _data["offerPriceId"];
            this.rate = _data["rate"];
        }
    }

    static fromJS(data: any): RateDriverByOfferDto {
        data = typeof data === 'object' ? data : {};
        let result = new RateDriverByOfferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offerPriceId"] = this.offerPriceId;
        data["rate"] = this.rate;
        return data; 
    }

    clone(): RateDriverByOfferDto {
        const json = this.toJSON();
        let result = new RateDriverByOfferDto();
        result.init(json);
        return result;
    }
}

export interface IRateDriverByOfferDto {
    offerPriceId: number;
    rate: number;
}

export class RateDriverByRequestDto implements IRateDriverByRequestDto {
    requestId: number;
    rate: number;

    constructor(data?: IRateDriverByRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
            this.rate = _data["rate"];
        }
    }

    static fromJS(data: any): RateDriverByRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new RateDriverByRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["rate"] = this.rate;
        return data; 
    }

    clone(): RateDriverByRequestDto {
        const json = this.toJSON();
        let result = new RateDriverByRequestDto();
        result.init(json);
        return result;
    }
}

export interface IRateDriverByRequestDto {
    requestId: number;
    rate: number;
}

export class ChangeOfferPriceStatus implements IChangeOfferPriceStatus {
    offerPriceId: number;
    status: number;

    constructor(data?: IChangeOfferPriceStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offerPriceId = _data["offerPriceId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ChangeOfferPriceStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeOfferPriceStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offerPriceId"] = this.offerPriceId;
        data["status"] = this.status;
        return data; 
    }

    clone(): ChangeOfferPriceStatus {
        const json = this.toJSON();
        let result = new ChangeOfferPriceStatus();
        result.init(json);
        return result;
    }
}

export interface IChangeOfferPriceStatus {
    offerPriceId: number;
    status: number;
}

export class GetOfferPriceDto implements IGetOfferPriceDto {
    requestId: number;

    constructor(data?: IGetOfferPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): GetOfferPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOfferPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        return data; 
    }

    clone(): GetOfferPriceDto {
        const json = this.toJSON();
        let result = new GetOfferPriceDto();
        result.init(json);
        return result;
    }
}

export interface IGetOfferPriceDto {
    requestId: number;
}

export class OfferPriceDto implements IOfferPriceDto {
    vat: number;
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    driverId: number;
    driverName: string | undefined;
    clientName: string | undefined;
    offerStatus: number;
    isRated: boolean | undefined;
    rate: number | undefined;
    isRead: boolean | undefined;
    isDriverRead: boolean | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    userId: number | undefined;
    id: number;

    constructor(data?: IOfferPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vat = _data["vat"];
            this.deliveryCost = _data["deliveryCost"];
            this.awayFrom = _data["awayFrom"];
            this.deliveryThroughDays = _data["deliveryThroughDays"];
            this.deliveryThroughHours = _data["deliveryThroughHours"];
            this.deliveryThroughMinutes = _data["deliveryThroughMinutes"];
            this.deliveryThroughSeconds = _data["deliveryThroughSeconds"];
            this.requestId = _data["requestId"];
            this.driverId = _data["driverId"];
            this.driverName = _data["driverName"];
            this.clientName = _data["clientName"];
            this.offerStatus = _data["offerStatus"];
            this.isRated = _data["isRated"];
            this.rate = _data["rate"];
            this.isRead = _data["isRead"];
            this.isDriverRead = _data["isDriverRead"];
            this.isClientRated = _data["isClientRated"];
            this.clientRate = _data["clientRate"];
            this.userId = _data["userId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OfferPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vat"] = this.vat;
        data["deliveryCost"] = this.deliveryCost;
        data["awayFrom"] = this.awayFrom;
        data["deliveryThroughDays"] = this.deliveryThroughDays;
        data["deliveryThroughHours"] = this.deliveryThroughHours;
        data["deliveryThroughMinutes"] = this.deliveryThroughMinutes;
        data["deliveryThroughSeconds"] = this.deliveryThroughSeconds;
        data["requestId"] = this.requestId;
        data["driverId"] = this.driverId;
        data["driverName"] = this.driverName;
        data["clientName"] = this.clientName;
        data["offerStatus"] = this.offerStatus;
        data["isRated"] = this.isRated;
        data["rate"] = this.rate;
        data["isRead"] = this.isRead;
        data["isDriverRead"] = this.isDriverRead;
        data["isClientRated"] = this.isClientRated;
        data["clientRate"] = this.clientRate;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }

    clone(): OfferPriceDto {
        const json = this.toJSON();
        let result = new OfferPriceDto();
        result.init(json);
        return result;
    }
}

export interface IOfferPriceDto {
    vat: number;
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    driverId: number;
    driverName: string | undefined;
    clientName: string | undefined;
    offerStatus: number;
    isRated: boolean | undefined;
    rate: number | undefined;
    isRead: boolean | undefined;
    isDriverRead: boolean | undefined;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    userId: number | undefined;
    id: number;
}

export class OfferPriceDtoPagedResultDto implements IOfferPriceDtoPagedResultDto {
    totalCount: number;
    items: OfferPriceDto[] | undefined;

    constructor(data?: IOfferPriceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(OfferPriceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OfferPriceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferPriceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OfferPriceDtoPagedResultDto {
        const json = this.toJSON();
        let result = new OfferPriceDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IOfferPriceDtoPagedResultDto {
    totalCount: number;
    items: OfferPriceDto[] | undefined;
}

export class UpdateOfferPriceDto implements IUpdateOfferPriceDto {
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    id: number;

    constructor(data?: IUpdateOfferPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deliveryCost = _data["deliveryCost"];
            this.awayFrom = _data["awayFrom"];
            this.deliveryThroughDays = _data["deliveryThroughDays"];
            this.deliveryThroughHours = _data["deliveryThroughHours"];
            this.deliveryThroughMinutes = _data["deliveryThroughMinutes"];
            this.deliveryThroughSeconds = _data["deliveryThroughSeconds"];
            this.requestId = _data["requestId"];
            this.isClientRated = _data["isClientRated"];
            this.clientRate = _data["clientRate"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateOfferPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOfferPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryCost"] = this.deliveryCost;
        data["awayFrom"] = this.awayFrom;
        data["deliveryThroughDays"] = this.deliveryThroughDays;
        data["deliveryThroughHours"] = this.deliveryThroughHours;
        data["deliveryThroughMinutes"] = this.deliveryThroughMinutes;
        data["deliveryThroughSeconds"] = this.deliveryThroughSeconds;
        data["requestId"] = this.requestId;
        data["isClientRated"] = this.isClientRated;
        data["clientRate"] = this.clientRate;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateOfferPriceDto {
        const json = this.toJSON();
        let result = new UpdateOfferPriceDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateOfferPriceDto {
    deliveryCost: number;
    awayFrom: string | undefined;
    deliveryThroughDays: number;
    deliveryThroughHours: number;
    deliveryThroughMinutes: number;
    deliveryThroughSeconds: number;
    requestId: number;
    isClientRated: boolean | undefined;
    clientRate: number | undefined;
    id: number;
}

export class OfferPriceStatusDto implements IOfferPriceStatusDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    id: number;

    constructor(data?: IOfferPriceStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OfferPriceStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferPriceStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["id"] = this.id;
        return data; 
    }

    clone(): OfferPriceStatusDto {
        const json = this.toJSON();
        let result = new OfferPriceStatusDto();
        result.init(json);
        return result;
    }
}

export interface IOfferPriceStatusDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    id: number;
}

export class OfferPriceStatusDtoPagedResultDto implements IOfferPriceStatusDtoPagedResultDto {
    totalCount: number;
    items: OfferPriceStatusDto[] | undefined;

    constructor(data?: IOfferPriceStatusDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(OfferPriceStatusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OfferPriceStatusDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferPriceStatusDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OfferPriceStatusDtoPagedResultDto {
        const json = this.toJSON();
        let result = new OfferPriceStatusDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IOfferPriceStatusDtoPagedResultDto {
    totalCount: number;
    items: OfferPriceStatusDto[] | undefined;
}

export class CreateOfferPriceStatusDto implements ICreateOfferPriceStatusDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    id: number;

    constructor(data?: ICreateOfferPriceStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOfferPriceStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOfferPriceStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOfferPriceStatusDto {
        const json = this.toJSON();
        let result = new CreateOfferPriceStatusDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOfferPriceStatusDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    id: number;
}

export class UpdateOfferPriceStatusDto implements IUpdateOfferPriceStatusDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    id: number;

    constructor(data?: IUpdateOfferPriceStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateOfferPriceStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOfferPriceStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateOfferPriceStatusDto {
        const json = this.toJSON();
        let result = new UpdateOfferPriceStatusDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateOfferPriceStatusDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    id: number;
}

export enum PaymentTypes {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class CreatePaymentDetailDto implements ICreatePaymentDetailDto {
    paymentId: number;
    payValue: number;
    paymentType: PaymentTypes;

    constructor(data?: ICreatePaymentDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.payValue = _data["payValue"];
            this.paymentType = _data["paymentType"];
        }
    }

    static fromJS(data: any): CreatePaymentDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["payValue"] = this.payValue;
        data["paymentType"] = this.paymentType;
        return data; 
    }

    clone(): CreatePaymentDetailDto {
        const json = this.toJSON();
        let result = new CreatePaymentDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePaymentDetailDto {
    paymentId: number;
    payValue: number;
    paymentType: PaymentTypes;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    clientId: number;
    requestId: number;
    couponCode: string | undefined;
    couponType: CouponTypes;
    couponValue: number | undefined;
    cost: number;
    costAfterDiscount: number | undefined;
    paymentDetails: CreatePaymentDetailDto[] | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.requestId = _data["requestId"];
            this.couponCode = _data["couponCode"];
            this.couponType = _data["couponType"];
            this.couponValue = _data["couponValue"];
            this.cost = _data["cost"];
            this.costAfterDiscount = _data["costAfterDiscount"];
            if (Array.isArray(_data["paymentDetails"])) {
                this.paymentDetails = [] as any;
                for (let item of _data["paymentDetails"])
                    this.paymentDetails.push(CreatePaymentDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["requestId"] = this.requestId;
        data["couponCode"] = this.couponCode;
        data["couponType"] = this.couponType;
        data["couponValue"] = this.couponValue;
        data["cost"] = this.cost;
        data["costAfterDiscount"] = this.costAfterDiscount;
        if (Array.isArray(this.paymentDetails)) {
            data["paymentDetails"] = [];
            for (let item of this.paymentDetails)
                data["paymentDetails"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreatePaymentDto {
        const json = this.toJSON();
        let result = new CreatePaymentDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePaymentDto {
    clientId: number;
    requestId: number;
    couponCode: string | undefined;
    couponType: CouponTypes;
    couponValue: number | undefined;
    cost: number;
    costAfterDiscount: number | undefined;
    paymentDetails: CreatePaymentDetailDto[] | undefined;
}

export class PaymentDetailDto implements IPaymentDetailDto {
    paymentId: number;
    creationTime: moment.Moment;
    payValue: number;
    paymentType: PaymentTypes;
    id: number;

    constructor(data?: IPaymentDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.payValue = _data["payValue"];
            this.paymentType = _data["paymentType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["payValue"] = this.payValue;
        data["paymentType"] = this.paymentType;
        data["id"] = this.id;
        return data; 
    }

    clone(): PaymentDetailDto {
        const json = this.toJSON();
        let result = new PaymentDetailDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentDetailDto {
    paymentId: number;
    creationTime: moment.Moment;
    payValue: number;
    paymentType: PaymentTypes;
    id: number;
}

export class PaymentDto implements IPaymentDto {
    clientId: number;
    client: ClientDto;
    requestId: number;
    couponCode: string | undefined;
    couponType: CouponTypes;
    couponValue: number | undefined;
    cost: number;
    costAfterDiscount: number | undefined;
    driverName: string | undefined;
    clientName: string | undefined;
    paymentDetails: PaymentDetailDto[] | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.client = _data["client"] ? ClientDto.fromJS(_data["client"]) : <any>undefined;
            this.requestId = _data["requestId"];
            this.couponCode = _data["couponCode"];
            this.couponType = _data["couponType"];
            this.couponValue = _data["couponValue"];
            this.cost = _data["cost"];
            this.costAfterDiscount = _data["costAfterDiscount"];
            this.driverName = _data["driverName"];
            this.clientName = _data["clientName"];
            if (Array.isArray(_data["paymentDetails"])) {
                this.paymentDetails = [] as any;
                for (let item of _data["paymentDetails"])
                    this.paymentDetails.push(PaymentDetailDto.fromJS(item));
            }
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["requestId"] = this.requestId;
        data["couponCode"] = this.couponCode;
        data["couponType"] = this.couponType;
        data["couponValue"] = this.couponValue;
        data["cost"] = this.cost;
        data["costAfterDiscount"] = this.costAfterDiscount;
        data["driverName"] = this.driverName;
        data["clientName"] = this.clientName;
        if (Array.isArray(this.paymentDetails)) {
            data["paymentDetails"] = [];
            for (let item of this.paymentDetails)
                data["paymentDetails"].push(item.toJSON());
        }
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PaymentDto {
        const json = this.toJSON();
        let result = new PaymentDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentDto {
    clientId: number;
    client: ClientDto;
    requestId: number;
    couponCode: string | undefined;
    couponType: CouponTypes;
    couponValue: number | undefined;
    cost: number;
    costAfterDiscount: number | undefined;
    driverName: string | undefined;
    clientName: string | undefined;
    paymentDetails: PaymentDetailDto[] | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class HyperRequestDto implements IHyperRequestDto {
    amount: number;
    currency: string | undefined;

    constructor(data?: IHyperRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): HyperRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new HyperRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        return data; 
    }

    clone(): HyperRequestDto {
        const json = this.toJSON();
        let result = new HyperRequestDto();
        result.init(json);
        return result;
    }
}

export interface IHyperRequestDto {
    amount: number;
    currency: string | undefined;
}

export class Result implements IResult {
    code: string | undefined;
    description: string | undefined;

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        return data; 
    }

    clone(): Result {
        const json = this.toJSON();
        let result = new Result();
        result.init(json);
        return result;
    }
}

export interface IResult {
    code: string | undefined;
    description: string | undefined;
}

export class CheckOutResponse implements ICheckOutResponse {
    result: Result;
    buildNumber: string | undefined;
    timestamp: moment.Moment;
    ndc: string | undefined;
    id: string | undefined;

    constructor(data?: ICheckOutResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? Result.fromJS(_data["result"]) : <any>undefined;
            this.buildNumber = _data["buildNumber"];
            this.timestamp = _data["timestamp"] ? moment(_data["timestamp"].toString()) : <any>undefined;
            this.ndc = _data["ndc"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CheckOutResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CheckOutResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["buildNumber"] = this.buildNumber;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["ndc"] = this.ndc;
        data["id"] = this.id;
        return data; 
    }

    clone(): CheckOutResponse {
        const json = this.toJSON();
        let result = new CheckOutResponse();
        result.init(json);
        return result;
    }
}

export interface ICheckOutResponse {
    result: Result;
    buildNumber: string | undefined;
    timestamp: moment.Moment;
    ndc: string | undefined;
    id: string | undefined;
}

export class PaymentDtoPagedResultDto implements IPaymentDtoPagedResultDto {
    totalCount: number;
    items: PaymentDto[] | undefined;

    constructor(data?: IPaymentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PaymentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PaymentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PaymentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentDtoPagedResultDto {
    totalCount: number;
    items: PaymentDto[] | undefined;
}

export class UpdatePaymentDto implements IUpdatePaymentDto {
    clientId: number;
    requestId: number;
    couponCode: string | undefined;
    couponType: CouponTypes;
    couponValue: number | undefined;
    cost: number;
    costAfterDiscount: number | undefined;
    id: number;

    constructor(data?: IUpdatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.requestId = _data["requestId"];
            this.couponCode = _data["couponCode"];
            this.couponType = _data["couponType"];
            this.couponValue = _data["couponValue"];
            this.cost = _data["cost"];
            this.costAfterDiscount = _data["costAfterDiscount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["requestId"] = this.requestId;
        data["couponCode"] = this.couponCode;
        data["couponType"] = this.couponType;
        data["couponValue"] = this.couponValue;
        data["cost"] = this.cost;
        data["costAfterDiscount"] = this.costAfterDiscount;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdatePaymentDto {
        const json = this.toJSON();
        let result = new UpdatePaymentDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePaymentDto {
    clientId: number;
    requestId: number;
    couponCode: string | undefined;
    couponType: CouponTypes;
    couponValue: number | undefined;
    cost: number;
    costAfterDiscount: number | undefined;
    id: number;
}

export class PaymentDetailDtoPagedResultDto implements IPaymentDetailDtoPagedResultDto {
    totalCount: number;
    items: PaymentDetailDto[] | undefined;

    constructor(data?: IPaymentDetailDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PaymentDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentDetailDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentDetailDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PaymentDetailDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PaymentDetailDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentDetailDtoPagedResultDto {
    totalCount: number;
    items: PaymentDetailDto[] | undefined;
}

export class UpdatePaymentDetailDto implements IUpdatePaymentDetailDto {
    paymentId: number;
    payValue: number;
    paymentType: PaymentTypes;
    id: number;

    constructor(data?: IUpdatePaymentDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.payValue = _data["payValue"];
            this.paymentType = _data["paymentType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePaymentDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePaymentDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["payValue"] = this.payValue;
        data["paymentType"] = this.paymentType;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdatePaymentDetailDto {
        const json = this.toJSON();
        let result = new UpdatePaymentDetailDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePaymentDetailDto {
    paymentId: number;
    payValue: number;
    paymentType: PaymentTypes;
    id: number;
}

export class PlateTypeDto implements IPlateTypeDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    id: number;

    constructor(data?: IPlateTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PlateTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlateTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["id"] = this.id;
        return data; 
    }

    clone(): PlateTypeDto {
        const json = this.toJSON();
        let result = new PlateTypeDto();
        result.init(json);
        return result;
    }
}

export interface IPlateTypeDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    id: number;
}

export class PlateTypeDtoPagedResultDto implements IPlateTypeDtoPagedResultDto {
    totalCount: number;
    items: PlateTypeDto[] | undefined;

    constructor(data?: IPlateTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PlateTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlateTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlateTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PlateTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PlateTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPlateTypeDtoPagedResultDto {
    totalCount: number;
    items: PlateTypeDto[] | undefined;
}

export class CreatePlateTypeDto implements ICreatePlateTypeDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    id: number;

    constructor(data?: ICreatePlateTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreatePlateTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePlateTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreatePlateTypeDto {
        const json = this.toJSON();
        let result = new CreatePlateTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePlateTypeDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    id: number;
}

export class UpdatePlateTypeDto implements IUpdatePlateTypeDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    id: number;

    constructor(data?: IUpdatePlateTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePlateTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePlateTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdatePlateTypeDto {
        const json = this.toJSON();
        let result = new UpdatePlateTypeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePlateTypeDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    id: number;
}

export class CreateRequestDto implements ICreateRequestDto {
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    deliveryCost: string | undefined;
    status: number;
    receiverMobile: string | undefined;
    driverId: number | undefined;

    constructor(data?: ICreateRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.discountPercentage = _data["discountPercentage"];
            this.arrivalDateTime = _data["arrivalDateTime"] ? moment(_data["arrivalDateTime"].toString()) : <any>undefined;
            this.paymentWay = _data["paymentWay"];
            this.notes = _data["notes"];
            this.startingPoint = _data["startingPoint"];
            this.endingPoint = _data["endingPoint"];
            this.stratingPointAdress = _data["stratingPointAdress"];
            this.stratingPointTitle = _data["stratingPointTitle"];
            this.endingPointAdress = _data["endingPointAdress"];
            this.endingPointTitle = _data["endingPointTitle"];
            this.subcategoryId = _data["subcategoryId"];
            this.deliveryCost = _data["deliveryCost"];
            this.status = _data["status"];
            this.receiverMobile = _data["receiverMobile"];
            this.driverId = _data["driverId"];
        }
    }

    static fromJS(data: any): CreateRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discountPercentage"] = this.discountPercentage;
        data["arrivalDateTime"] = this.arrivalDateTime ? this.arrivalDateTime.toISOString() : <any>undefined;
        data["paymentWay"] = this.paymentWay;
        data["notes"] = this.notes;
        data["startingPoint"] = this.startingPoint;
        data["endingPoint"] = this.endingPoint;
        data["stratingPointAdress"] = this.stratingPointAdress;
        data["stratingPointTitle"] = this.stratingPointTitle;
        data["endingPointAdress"] = this.endingPointAdress;
        data["endingPointTitle"] = this.endingPointTitle;
        data["subcategoryId"] = this.subcategoryId;
        data["deliveryCost"] = this.deliveryCost;
        data["status"] = this.status;
        data["receiverMobile"] = this.receiverMobile;
        data["driverId"] = this.driverId;
        return data; 
    }

    clone(): CreateRequestDto {
        const json = this.toJSON();
        let result = new CreateRequestDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRequestDto {
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    subcategoryId: number;
    deliveryCost: string | undefined;
    status: number;
    receiverMobile: string | undefined;
    driverId: number | undefined;
}

export class RequestDtoPagedResultDto implements IRequestDtoPagedResultDto {
    totalCount: number;
    items: RequestDto[] | undefined;

    constructor(data?: IRequestDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RequestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RequestDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RequestDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRequestDtoPagedResultDto {
    totalCount: number;
    items: RequestDto[] | undefined;
}

export enum UserType {
    _1 = 1,
    _2 = 2,
}

export class RejectClientRequestInput implements IRejectClientRequestInput {
    requestId: number;
    driverId: number;

    constructor(data?: IRejectClientRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
            this.driverId = _data["driverId"];
        }
    }

    static fromJS(data: any): RejectClientRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new RejectClientRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["driverId"] = this.driverId;
        return data; 
    }

    clone(): RejectClientRequestInput {
        const json = this.toJSON();
        let result = new RejectClientRequestInput();
        result.init(json);
        return result;
    }
}

export interface IRejectClientRequestInput {
    requestId: number;
    driverId: number;
}

export class UpdateRquestDto implements IUpdateRquestDto {
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    endingPoint: string | undefined;
    subcategoryId: number;
    deliveryCost: string | undefined;
    status: number;
    id: number;

    constructor(data?: IUpdateRquestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.discountPercentage = _data["discountPercentage"];
            this.arrivalDateTime = _data["arrivalDateTime"] ? moment(_data["arrivalDateTime"].toString()) : <any>undefined;
            this.paymentWay = _data["paymentWay"];
            this.notes = _data["notes"];
            this.startingPoint = _data["startingPoint"];
            this.stratingPointAdress = _data["stratingPointAdress"];
            this.stratingPointTitle = _data["stratingPointTitle"];
            this.endingPointAdress = _data["endingPointAdress"];
            this.endingPointTitle = _data["endingPointTitle"];
            this.endingPoint = _data["endingPoint"];
            this.subcategoryId = _data["subcategoryId"];
            this.deliveryCost = _data["deliveryCost"];
            this.status = _data["status"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateRquestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRquestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discountPercentage"] = this.discountPercentage;
        data["arrivalDateTime"] = this.arrivalDateTime ? this.arrivalDateTime.toISOString() : <any>undefined;
        data["paymentWay"] = this.paymentWay;
        data["notes"] = this.notes;
        data["startingPoint"] = this.startingPoint;
        data["stratingPointAdress"] = this.stratingPointAdress;
        data["stratingPointTitle"] = this.stratingPointTitle;
        data["endingPointAdress"] = this.endingPointAdress;
        data["endingPointTitle"] = this.endingPointTitle;
        data["endingPoint"] = this.endingPoint;
        data["subcategoryId"] = this.subcategoryId;
        data["deliveryCost"] = this.deliveryCost;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateRquestDto {
        const json = this.toJSON();
        let result = new UpdateRquestDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateRquestDto {
    discountPercentage: number;
    arrivalDateTime: moment.Moment;
    paymentWay: number;
    notes: string | undefined;
    startingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    stratingPointTitle: string | undefined;
    endingPointAdress: string | undefined;
    endingPointTitle: string | undefined;
    endingPoint: string | undefined;
    subcategoryId: number;
    deliveryCost: string | undefined;
    status: number;
    id: number;
}

export class RequestStateDto implements IRequestStateDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    id: number;

    constructor(data?: IRequestStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RequestStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["id"] = this.id;
        return data; 
    }

    clone(): RequestStateDto {
        const json = this.toJSON();
        let result = new RequestStateDto();
        result.init(json);
        return result;
    }
}

export interface IRequestStateDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    id: number;
}

export class RequestStateDtoPagedResultDto implements IRequestStateDtoPagedResultDto {
    totalCount: number;
    items: RequestStateDto[] | undefined;

    constructor(data?: IRequestStateDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RequestStateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestStateDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStateDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RequestStateDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RequestStateDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRequestStateDtoPagedResultDto {
    totalCount: number;
    items: RequestStateDto[] | undefined;
}

export class CreateRequestStateDto implements ICreateRequestStateDto {
    name: string | undefined;
    nameAr: string | undefined;
    id: number;

    constructor(data?: ICreateRequestStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateRequestStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRequestStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateRequestStateDto {
        const json = this.toJSON();
        let result = new CreateRequestStateDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRequestStateDto {
    name: string | undefined;
    nameAr: string | undefined;
    id: number;
}

export class UpdateRequestStateDto implements IUpdateRequestStateDto {
    name: string | undefined;
    nameAr: string | undefined;
    id: number;

    constructor(data?: IUpdateRequestStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateRequestStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRequestStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateRequestStateDto {
        const json = this.toJSON();
        let result = new UpdateRequestStateDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateRequestStateDto {
    name: string | undefined;
    nameAr: string | undefined;
    id: number;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string | undefined;
    displayName: string | undefined;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string | undefined;
    displayName: string | undefined;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isStatic: boolean;
    id: number;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isStatic: boolean;
    id: number;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        this.features[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class SubcategoryDtoPagedResultDto implements ISubcategoryDtoPagedResultDto {
    totalCount: number;
    items: SubcategoryDto[] | undefined;

    constructor(data?: ISubcategoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SubcategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubcategoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubcategoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SubcategoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SubcategoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISubcategoryDtoPagedResultDto {
    totalCount: number;
    items: SubcategoryDto[] | undefined;
}

export class CreateSubcategoryDto implements ICreateSubcategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    categoryId: number;

    constructor(data?: ICreateSubcategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionFa = _data["descriptionFa"];
            this.image = _data["image"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): CreateSubcategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubcategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionFa"] = this.descriptionFa;
        data["image"] = this.image;
        data["categoryId"] = this.categoryId;
        return data; 
    }

    clone(): CreateSubcategoryDto {
        const json = this.toJSON();
        let result = new CreateSubcategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSubcategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    categoryId: number;
}

export class UpdateSubcategoryDto implements IUpdateSubcategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    categoryId: number;
    id: number;

    constructor(data?: IUpdateSubcategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.nameFa = _data["nameFa"];
            this.description = _data["description"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionFa = _data["descriptionFa"];
            this.image = _data["image"];
            this.categoryId = _data["categoryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateSubcategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSubcategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["nameFa"] = this.nameFa;
        data["description"] = this.description;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionFa"] = this.descriptionFa;
        data["image"] = this.image;
        data["categoryId"] = this.categoryId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateSubcategoryDto {
        const json = this.toJSON();
        let result = new UpdateSubcategoryDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateSubcategoryDto {
    name: string | undefined;
    nameAr: string | undefined;
    nameFa: string | undefined;
    description: string | undefined;
    descriptionAr: string | undefined;
    descriptionFa: string | undefined;
    image: string | undefined;
    categoryId: number;
    id: number;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string | undefined;
    name: string | undefined;
    adminEmailAddress: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string | undefined;
    name: string | undefined;
    adminEmailAddress: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
}

export class TenantDto implements ITenantDto {
    tenancyName: string | undefined;
    name: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string | undefined;
    name: string | undefined;
    isActive: boolean;
    id: number;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string | undefined;
    password: string | undefined;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string | undefined;
    password: string | undefined;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    availableEditDelete: boolean;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
            this.availableEditDelete = _data["availableEditDelete"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["availableEditDelete"] = this.availableEditDelete;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    availableEditDelete: boolean;
}

export class AuthenticateAdminModel implements IAuthenticateAdminModel {
    usernameOrEmailAddress: string | undefined;
    password: string | undefined;

    constructor(data?: IAuthenticateAdminModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usernameOrEmailAddress = _data["usernameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticateAdminModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateAdminModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }

    clone(): AuthenticateAdminModel {
        const json = this.toJSON();
        let result = new AuthenticateAdminModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateAdminModel {
    usernameOrEmailAddress: string | undefined;
    password: string | undefined;
}

export class AuthenticateByPhoneModel implements IAuthenticateByPhoneModel {
    phone: string | undefined;

    constructor(data?: IAuthenticateByPhoneModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): AuthenticateByPhoneModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateByPhoneModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        return data; 
    }

    clone(): AuthenticateByPhoneModel {
        const json = this.toJSON();
        let result = new AuthenticateByPhoneModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateByPhoneModel {
    phone: string | undefined;
}

export class ResultCodeSms implements IResultCodeSms {
    resultCode: number;

    constructor(data?: IResultCodeSms) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resultCode = _data["resultCode"];
        }
    }

    static fromJS(data: any): ResultCodeSms {
        data = typeof data === 'object' ? data : {};
        let result = new ResultCodeSms();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resultCode"] = this.resultCode;
        return data; 
    }

    clone(): ResultCodeSms {
        const json = this.toJSON();
        let result = new ResultCodeSms();
        result.init(json);
        return result;
    }
}

export interface IResultCodeSms {
    resultCode: number;
}

export class AuthenticateByPhoneConfirmModel implements IAuthenticateByPhoneConfirmModel {
    phone: string | undefined;
    code: string | undefined;

    constructor(data?: IAuthenticateByPhoneConfirmModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): AuthenticateByPhoneConfirmModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateByPhoneConfirmModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["code"] = this.code;
        return data; 
    }

    clone(): AuthenticateByPhoneConfirmModel {
        const json = this.toJSON();
        let result = new AuthenticateByPhoneConfirmModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateByPhoneConfirmModel {
    phone: string | undefined;
    code: string | undefined;
}

export class AuthenticateClientResultModel implements IAuthenticateClientResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    isNew: boolean;
    isDriver: boolean;
    isHasePrifle: boolean;
    profile: ClientDto;

    constructor(data?: IAuthenticateClientResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
            this.isNew = _data["isNew"];
            this.isDriver = _data["isDriver"];
            this.isHasePrifle = _data["isHasePrifle"];
            this.profile = _data["profile"] ? ClientDto.fromJS(_data["profile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthenticateClientResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateClientResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["isNew"] = this.isNew;
        data["isDriver"] = this.isDriver;
        data["isHasePrifle"] = this.isHasePrifle;
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AuthenticateClientResultModel {
        const json = this.toJSON();
        let result = new AuthenticateClientResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateClientResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    isNew: boolean;
    isDriver: boolean;
    isHasePrifle: boolean;
    profile: ClientDto;
}

export class AuthenticateDriverResultModel implements IAuthenticateDriverResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    isNew: boolean;
    isDriver: boolean;
    isHasePrifle: boolean;
    profile: DriverDto;

    constructor(data?: IAuthenticateDriverResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
            this.isNew = _data["isNew"];
            this.isDriver = _data["isDriver"];
            this.isHasePrifle = _data["isHasePrifle"];
            this.profile = _data["profile"] ? DriverDto.fromJS(_data["profile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthenticateDriverResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateDriverResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["isNew"] = this.isNew;
        data["isDriver"] = this.isDriver;
        data["isHasePrifle"] = this.isHasePrifle;
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AuthenticateDriverResultModel {
        const json = this.toJSON();
        let result = new AuthenticateDriverResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateDriverResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    isNew: boolean;
    isDriver: boolean;
    isHasePrifle: boolean;
    profile: DriverDto;
}

export class ShortDriverInfo implements IShortDriverInfo {
    fullName: string | undefined;
    mobileNumber: string | undefined;
    plate: string | undefined;
    id: number;

    constructor(data?: IShortDriverInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.mobileNumber = _data["mobileNumber"];
            this.plate = _data["plate"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ShortDriverInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ShortDriverInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["mobileNumber"] = this.mobileNumber;
        data["plate"] = this.plate;
        data["id"] = this.id;
        return data; 
    }

    clone(): ShortDriverInfo {
        const json = this.toJSON();
        let result = new ShortDriverInfo();
        result.init(json);
        return result;
    }
}

export interface IShortDriverInfo {
    fullName: string | undefined;
    mobileNumber: string | undefined;
    plate: string | undefined;
    id: number;
}

export class ShortRequestDto implements IShortRequestDto {
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    endingPointAdress: string | undefined;
    id: number;

    constructor(data?: IShortRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startingPoint = _data["startingPoint"];
            this.endingPoint = _data["endingPoint"];
            this.stratingPointAdress = _data["stratingPointAdress"];
            this.endingPointAdress = _data["endingPointAdress"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ShortRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShortRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startingPoint"] = this.startingPoint;
        data["endingPoint"] = this.endingPoint;
        data["stratingPointAdress"] = this.stratingPointAdress;
        data["endingPointAdress"] = this.endingPointAdress;
        data["id"] = this.id;
        return data; 
    }

    clone(): ShortRequestDto {
        const json = this.toJSON();
        let result = new ShortRequestDto();
        result.init(json);
        return result;
    }
}

export interface IShortRequestDto {
    startingPoint: string | undefined;
    endingPoint: string | undefined;
    stratingPointAdress: string | undefined;
    endingPointAdress: string | undefined;
    id: number;
}

export class TrackingTripDto implements ITrackingTripDto {
    driverId: number;
    driver: ShortDriverInfo;
    requestId: number;
    request: ShortRequestDto;
    latitude: string | undefined;
    longitude: string | undefined;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: ITrackingTripDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.driverId = _data["driverId"];
            this.driver = _data["driver"] ? ShortDriverInfo.fromJS(_data["driver"]) : <any>undefined;
            this.requestId = _data["requestId"];
            this.request = _data["request"] ? ShortRequestDto.fromJS(_data["request"]) : <any>undefined;
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TrackingTripDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingTripDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["driverId"] = this.driverId;
        data["driver"] = this.driver ? this.driver.toJSON() : <any>undefined;
        data["requestId"] = this.requestId;
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): TrackingTripDto {
        const json = this.toJSON();
        let result = new TrackingTripDto();
        result.init(json);
        return result;
    }
}

export interface ITrackingTripDto {
    driverId: number;
    driver: ShortDriverInfo;
    requestId: number;
    request: ShortRequestDto;
    latitude: string | undefined;
    longitude: string | undefined;
    creationTime: moment.Moment;
    id: number;
}

export class TrackingApiDto implements ITrackingApiDto {
    trackingTrips: TrackingTripDto[] | undefined;
    message: string | undefined;
    success: boolean;
    id: number;

    constructor(data?: ITrackingApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["trackingTrips"])) {
                this.trackingTrips = [] as any;
                for (let item of _data["trackingTrips"])
                    this.trackingTrips.push(TrackingTripDto.fromJS(item));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TrackingApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.trackingTrips)) {
            data["trackingTrips"] = [];
            for (let item of this.trackingTrips)
                data["trackingTrips"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["id"] = this.id;
        return data; 
    }

    clone(): TrackingApiDto {
        const json = this.toJSON();
        let result = new TrackingApiDto();
        result.init(json);
        return result;
    }
}

export interface ITrackingApiDto {
    trackingTrips: TrackingTripDto[] | undefined;
    message: string | undefined;
    success: boolean;
    id: number;
}

export class TrackingTripDtoPagedResultDto implements ITrackingTripDtoPagedResultDto {
    totalCount: number;
    items: TrackingTripDto[] | undefined;

    constructor(data?: ITrackingTripDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TrackingTripDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrackingTripDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingTripDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TrackingTripDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TrackingTripDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITrackingTripDtoPagedResultDto {
    totalCount: number;
    items: TrackingTripDto[] | undefined;
}

export class CreateTrackingTripDto implements ICreateTrackingTripDto {
    driverId: number;
    requestId: number;
    latitude: string | undefined;
    longitude: string | undefined;

    constructor(data?: ICreateTrackingTripDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.driverId = _data["driverId"];
            this.requestId = _data["requestId"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): CreateTrackingTripDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTrackingTripDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["driverId"] = this.driverId;
        data["requestId"] = this.requestId;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data; 
    }

    clone(): CreateTrackingTripDto {
        const json = this.toJSON();
        let result = new CreateTrackingTripDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTrackingTripDto {
    driverId: number;
    requestId: number;
    latitude: string | undefined;
    longitude: string | undefined;
}

export class UpdateTrackingTripDto implements IUpdateTrackingTripDto {
    driverId: number;
    requestId: number;
    latitude: string | undefined;
    longitude: string | undefined;
    id: number;

    constructor(data?: IUpdateTrackingTripDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.driverId = _data["driverId"];
            this.requestId = _data["requestId"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateTrackingTripDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrackingTripDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["driverId"] = this.driverId;
        data["requestId"] = this.requestId;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateTrackingTripDto {
        const json = this.toJSON();
        let result = new UpdateTrackingTripDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateTrackingTripDto {
    driverId: number;
    requestId: number;
    latitude: string | undefined;
    longitude: string | undefined;
    id: number;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string | undefined;
}

export class UserDto implements IUserDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    id: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    id: number;
}

export class AdminMessageDto implements IAdminMessageDto {
    id: number;
    content: string | undefined;
    messageTime: moment.Moment;
    isFromAdmin: boolean;

    constructor(data?: IAdminMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.content = _data["content"];
            this.messageTime = _data["messageTime"] ? moment(_data["messageTime"].toString()) : <any>undefined;
            this.isFromAdmin = _data["isFromAdmin"];
        }
    }

    static fromJS(data: any): AdminMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["content"] = this.content;
        data["messageTime"] = this.messageTime ? this.messageTime.toISOString() : <any>undefined;
        data["isFromAdmin"] = this.isFromAdmin;
        return data; 
    }

    clone(): AdminMessageDto {
        const json = this.toJSON();
        let result = new AdminMessageDto();
        result.init(json);
        return result;
    }
}

export interface IAdminMessageDto {
    id: number;
    content: string | undefined;
    messageTime: moment.Moment;
    isFromAdmin: boolean;
}

export class AdminCreateMessageDto implements IAdminCreateMessageDto {
    content: string | undefined;
    to: number;

    constructor(data?: IAdminCreateMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.to = _data["to"];
        }
    }

    static fromJS(data: any): AdminCreateMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreateMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["to"] = this.to;
        return data; 
    }

    clone(): AdminCreateMessageDto {
        const json = this.toJSON();
        let result = new AdminCreateMessageDto();
        result.init(json);
        return result;
    }
}

export interface IAdminCreateMessageDto {
    content: string | undefined;
    to: number;
}

export class MessageDto implements IMessageDto {
    id: number;
    content: string | undefined;
    type: number;
    messageTime: moment.Moment;

    constructor(data?: IMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.content = _data["content"];
            this.type = _data["type"];
            this.messageTime = _data["messageTime"] ? moment(_data["messageTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["content"] = this.content;
        data["type"] = this.type;
        data["messageTime"] = this.messageTime ? this.messageTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): MessageDto {
        const json = this.toJSON();
        let result = new MessageDto();
        result.init(json);
        return result;
    }
}

export interface IMessageDto {
    id: number;
    content: string | undefined;
    type: number;
    messageTime: moment.Moment;
}

export class CreateMessageDto implements ICreateMessageDto {
    content: string | undefined;

    constructor(data?: ICreateMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): CreateMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        return data; 
    }

    clone(): CreateMessageDto {
        const json = this.toJSON();
        let result = new CreateMessageDto();
        result.init(json);
        return result;
    }
}

export interface ICreateMessageDto {
    content: string | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string | undefined;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string | undefined;
    newPassword: string | undefined;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string | undefined;
    newPassword: string | undefined;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string | undefined;
    userId: number;
    newPassword: string | undefined;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string | undefined;
    userId: number;
    newPassword: string | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    userID: number;
    roleName: string | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userID = _data["userID"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userID"] = this.userID;
        data["roleName"] = this.roleName;
        return data; 
    }

    clone(): UserRoleDto {
        const json = this.toJSON();
        let result = new UserRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleDto {
    userID: number;
    roleName: string | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;
}

export class WalletDto implements IWalletDto {
    clientId: number | undefined;
    driverId: number | undefined;
    walletValue: number;
    id: number;

    constructor(data?: IWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.driverId = _data["driverId"];
            this.walletValue = _data["walletValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["driverId"] = this.driverId;
        data["walletValue"] = this.walletValue;
        data["id"] = this.id;
        return data; 
    }

    clone(): WalletDto {
        const json = this.toJSON();
        let result = new WalletDto();
        result.init(json);
        return result;
    }
}

export interface IWalletDto {
    clientId: number | undefined;
    driverId: number | undefined;
    walletValue: number;
    id: number;
}

export class RechargeInput implements IRechargeInput {
    clientId: number;
    rechargeValue: number;

    constructor(data?: IRechargeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.rechargeValue = _data["rechargeValue"];
        }
    }

    static fromJS(data: any): RechargeInput {
        data = typeof data === 'object' ? data : {};
        let result = new RechargeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["rechargeValue"] = this.rechargeValue;
        return data; 
    }

    clone(): RechargeInput {
        const json = this.toJSON();
        let result = new RechargeInput();
        result.init(json);
        return result;
    }
}

export interface IRechargeInput {
    clientId: number;
    rechargeValue: number;
}

export class WalletDtoPagedResultDto implements IWalletDtoPagedResultDto {
    totalCount: number;
    items: WalletDto[] | undefined;

    constructor(data?: IWalletDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WalletDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WalletDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): WalletDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WalletDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWalletDtoPagedResultDto {
    totalCount: number;
    items: WalletDto[] | undefined;
}

export class CreateWalletDto implements ICreateWalletDto {
    clientId: number | undefined;
    driverId: number | undefined;
    walletValue: number;

    constructor(data?: ICreateWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.driverId = _data["driverId"];
            this.walletValue = _data["walletValue"];
        }
    }

    static fromJS(data: any): CreateWalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["driverId"] = this.driverId;
        data["walletValue"] = this.walletValue;
        return data; 
    }

    clone(): CreateWalletDto {
        const json = this.toJSON();
        let result = new CreateWalletDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWalletDto {
    clientId: number | undefined;
    driverId: number | undefined;
    walletValue: number;
}

export class UpdateWalletDto implements IUpdateWalletDto {
    clientId: number | undefined;
    driverId: number | undefined;
    walletValue: number;
    id: number;

    constructor(data?: IUpdateWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.driverId = _data["driverId"];
            this.walletValue = _data["walletValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["driverId"] = this.driverId;
        data["walletValue"] = this.walletValue;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateWalletDto {
        const json = this.toJSON();
        let result = new UpdateWalletDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWalletDto {
    clientId: number | undefined;
    driverId: number | undefined;
    walletValue: number;
    id: number;
}

export class TripRegVM implements ITripRegVM {
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    tripNumber: string | undefined;
    departureLatitude: number;
    departureLongitude: number;
    expectedDestinationLatitude: number;
    expectedDestinationLongitude: number;
    departedWhen: string | undefined;

    constructor(data?: ITripRegVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleSequenceNumber = _data["vehicleSequenceNumber"];
            this.driverIdentityNumber = _data["driverIdentityNumber"];
            this.tripNumber = _data["tripNumber"];
            this.departureLatitude = _data["departureLatitude"];
            this.departureLongitude = _data["departureLongitude"];
            this.expectedDestinationLatitude = _data["expectedDestinationLatitude"];
            this.expectedDestinationLongitude = _data["expectedDestinationLongitude"];
            this.departedWhen = _data["departedWhen"];
        }
    }

    static fromJS(data: any): TripRegVM {
        data = typeof data === 'object' ? data : {};
        let result = new TripRegVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleSequenceNumber"] = this.vehicleSequenceNumber;
        data["driverIdentityNumber"] = this.driverIdentityNumber;
        data["tripNumber"] = this.tripNumber;
        data["departureLatitude"] = this.departureLatitude;
        data["departureLongitude"] = this.departureLongitude;
        data["expectedDestinationLatitude"] = this.expectedDestinationLatitude;
        data["expectedDestinationLongitude"] = this.expectedDestinationLongitude;
        data["departedWhen"] = this.departedWhen;
        return data; 
    }

    clone(): TripRegVM {
        const json = this.toJSON();
        let result = new TripRegVM();
        result.init(json);
        return result;
    }
}

export interface ITripRegVM {
    vehicleSequenceNumber: string | undefined;
    driverIdentityNumber: string | undefined;
    tripNumber: string | undefined;
    departureLatitude: number;
    departureLongitude: number;
    expectedDestinationLatitude: number;
    expectedDestinationLongitude: number;
    departedWhen: string | undefined;
}

export class TripUpdateVM implements ITripUpdateVM {
    actualDestinationLatitude: number;
    actualDestinationLongitude: number;
    arrivedWhen: string | undefined;
    tripNumber: number;

    constructor(data?: ITripUpdateVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actualDestinationLatitude = _data["actualDestinationLatitude"];
            this.actualDestinationLongitude = _data["actualDestinationLongitude"];
            this.arrivedWhen = _data["arrivedWhen"];
            this.tripNumber = _data["tripNumber"];
        }
    }

    static fromJS(data: any): TripUpdateVM {
        data = typeof data === 'object' ? data : {};
        let result = new TripUpdateVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actualDestinationLatitude"] = this.actualDestinationLatitude;
        data["actualDestinationLongitude"] = this.actualDestinationLongitude;
        data["arrivedWhen"] = this.arrivedWhen;
        data["tripNumber"] = this.tripNumber;
        return data; 
    }

    clone(): TripUpdateVM {
        const json = this.toJSON();
        let result = new TripUpdateVM();
        result.init(json);
        return result;
    }
}

export interface ITripUpdateVM {
    actualDestinationLatitude: number;
    actualDestinationLongitude: number;
    arrivedWhen: string | undefined;
    tripNumber: number;
}

export class RegDriverVM implements IRegDriverVM {
    identityNumber: string | undefined;
    dateOfBirthGregorian: string | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    email: string | undefined;

    constructor(data?: IRegDriverVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identityNumber = _data["identityNumber"];
            this.dateOfBirthGregorian = _data["dateOfBirthGregorian"];
            this.dateOfBirthHijri = _data["dateOfBirthHijri"];
            this.mobileNumber = _data["mobileNumber"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): RegDriverVM {
        data = typeof data === 'object' ? data : {};
        let result = new RegDriverVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identityNumber"] = this.identityNumber;
        data["dateOfBirthGregorian"] = this.dateOfBirthGregorian;
        data["dateOfBirthHijri"] = this.dateOfBirthHijri;
        data["mobileNumber"] = this.mobileNumber;
        data["email"] = this.email;
        return data; 
    }

    clone(): RegDriverVM {
        const json = this.toJSON();
        let result = new RegDriverVM();
        result.init(json);
        return result;
    }
}

export interface IRegDriverVM {
    identityNumber: string | undefined;
    dateOfBirthGregorian: string | undefined;
    dateOfBirthHijri: string | undefined;
    mobileNumber: string | undefined;
    email: string | undefined;
}

export class VechileRegVm implements IVechileRegVm {
    sequenceNumber: string | undefined;
    plate: string | undefined;
    plateType: number;

    constructor(data?: IVechileRegVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sequenceNumber = _data["sequenceNumber"];
            this.plate = _data["plate"];
            this.plateType = _data["plateType"];
        }
    }

    static fromJS(data: any): VechileRegVm {
        data = typeof data === 'object' ? data : {};
        let result = new VechileRegVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sequenceNumber"] = this.sequenceNumber;
        data["plate"] = this.plate;
        data["plateType"] = this.plateType;
        return data; 
    }

    clone(): VechileRegVm {
        const json = this.toJSON();
        let result = new VechileRegVm();
        result.init(json);
        return result;
    }
}

export interface IVechileRegVm {
    sequenceNumber: string | undefined;
    plate: string | undefined;
    plateType: number;
}

export class FishVm implements IFishVm {
    id: number;
    name: string | undefined;
    nameAR: string | undefined;
    image: string | undefined;
    description: string | undefined;
    fishId: number;
    avgPrice: number;
    fishFamily: number;
    descriptionAR: string | undefined;
    token: string | undefined;

    constructor(data?: IFishVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nameAR = _data["nameAR"];
            this.image = _data["image"];
            this.description = _data["description"];
            this.fishId = _data["fishId"];
            this.avgPrice = _data["avgPrice"];
            this.fishFamily = _data["fishFamily"];
            this.descriptionAR = _data["descriptionAR"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): FishVm {
        data = typeof data === 'object' ? data : {};
        let result = new FishVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nameAR"] = this.nameAR;
        data["image"] = this.image;
        data["description"] = this.description;
        data["fishId"] = this.fishId;
        data["avgPrice"] = this.avgPrice;
        data["fishFamily"] = this.fishFamily;
        data["descriptionAR"] = this.descriptionAR;
        data["token"] = this.token;
        return data; 
    }

    clone(): FishVm {
        const json = this.toJSON();
        let result = new FishVm();
        result.init(json);
        return result;
    }
}

export interface IFishVm {
    id: number;
    name: string | undefined;
    nameAR: string | undefined;
    image: string | undefined;
    description: string | undefined;
    fishId: number;
    avgPrice: number;
    fishFamily: number;
    descriptionAR: string | undefined;
    token: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}